Estructura del directorio: C:\Users\Javier\OneDrive\Documentos\GitHub\MemoryProfiler

MemoryProfiler
‚îú‚îÄ‚îÄ .idea
‚îÇ   ‚îú‚îÄ‚îÄ .gitignore
‚îÇ   ‚îú‚îÄ‚îÄ MemoryProfiler.iml
‚îÇ   ‚îú‚îÄ‚îÄ editor.xml
‚îÇ   ‚îú‚îÄ‚îÄ misc.xml
‚îÇ   ‚îú‚îÄ‚îÄ modules.xml
‚îÇ   ‚îú‚îÄ‚îÄ shelf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Uncommitted_changes_before_Update_at_26_9_2025_03_12_[Changes]
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ shelved.patch
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Uncommitted_changes_before_Update_at_26_9_2025_03_12__Changes_.xml
‚îÇ   ‚îú‚îÄ‚îÄ vcs.xml
‚îÇ   ‚îú‚îÄ‚îÄ workspace.xml
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ Legacy
‚îÇ   ‚îú‚îÄ‚îÄ LegacyBridge.cpp
‚îÇ   ‚îú‚îÄ‚îÄ memprof.hpp
‚îÇ   ‚îú‚îÄ‚îÄ new_delete_overrides.cpp
‚îÇ   ‚îú‚îÄ‚îÄ registry.cpp
‚îÇ   ‚îú‚îÄ‚îÄ registry.hpp
‚îú‚îÄ‚îÄ examples
‚îÇ   ‚îú‚îÄ‚îÄ broker_client_example.cpp
‚îÇ   ‚îú‚îÄ‚îÄ metrics_stream.cpp
‚îú‚îÄ‚îÄ gui
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îú‚îÄ‚îÄ charts.js
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ style.css
‚îú‚îÄ‚îÄ include
‚îÇ   ‚îú‚îÄ‚îÄ BrokerClient.h
‚îÇ   ‚îú‚îÄ‚îÄ LegacyBridge.h
‚îÇ   ‚îú‚îÄ‚îÄ MemoryTracker.h
‚îÇ   ‚îú‚îÄ‚îÄ MetricsAggregator.h
‚îÇ   ‚îú‚îÄ‚îÄ MetricsCalculator.h
‚îÇ   ‚îú‚îÄ‚îÄ NetUtils.h
‚îÇ   ‚îú‚îÄ‚îÄ Protocol.h
‚îÇ   ‚îú‚îÄ‚îÄ SocketServer.h
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ BrokerClient.cpp
‚îÇ   ‚îú‚îÄ‚îÄ MemoryTracker.cpp
‚îÇ   ‚îú‚îÄ‚îÄ MetricsAggregator.cpp
‚îÇ   ‚îú‚îÄ‚îÄ MetricsCalculator.cpp
‚îÇ   ‚îú‚îÄ‚îÄ NetUtils.cpp
‚îÇ   ‚îú‚îÄ‚îÄ Protocol.cpp
‚îÇ   ‚îú‚îÄ‚îÄ SocketServer.cpp
‚îÇ   ‚îú‚îÄ‚îÄ gui_http_server.cpp
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îú‚îÄ‚îÄ test_metrics.cpp
‚îÇ   ‚îú‚îÄ‚îÄ test_socket.cpp
‚îú‚îÄ‚îÄ tree_with_content_COMPLETO.txt

================================================================================
CONTENIDO DE ARCHIVOS
================================================================================

CMakeLists.txt:
---------------
cmake_minimum_required(VERSION 3.20)
project(MemoryProfiler LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(LEGACY_DIR ${CMAKE_SOURCE_DIR}/Legacy)

# ========== Librer√≠a com√∫n ==========
add_library(mp_common STATIC
        src/Protocol.cpp
        src/NetUtils.cpp
)
target_include_directories(mp_common PUBLIC ${CMAKE_SOURCE_DIR}/include)
target_compile_features(mp_common PUBLIC cxx_std_20)
if (WIN32)
    target_link_libraries(mp_common PUBLIC ws2_32)
else()
    find_package(Threads REQUIRED)
    target_link_libraries(mp_common PUBLIC Threads::Threads)
endif()

# ========== SDK tracker ==========
add_library(mp_tracker STATIC src/MemoryTracker.cpp)
target_include_directories(mp_tracker PUBLIC ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(mp_tracker PUBLIC mp_common)
target_compile_features(mp_tracker PUBLIC cxx_std_20)

# ========== Servidor (broker) ==========
add_executable(memory_profiler_server
        src/main.cpp
        src/SocketServer.cpp
)
target_include_directories(memory_profiler_server PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(memory_profiler_server PRIVATE mp_common)
if (WIN32)
    target_link_libraries(memory_profiler_server PRIVATE ws2_32)
else()
    target_link_libraries(memory_profiler_server PRIVATE Threads::Threads)
endif()

# ========== Cliente broker (lib) ==========
add_library(mp_brokerclient STATIC src/BrokerClient.cpp)
target_include_directories(mp_brokerclient PUBLIC ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(mp_brokerclient PUBLIC mp_common)
if (WIN32)
    target_link_libraries(mp_brokerclient PUBLIC ws2_32)
endif()

# ========== M√©tricas (lib) ==========
add_library(mp_metrics STATIC src/MetricsCalculator.cpp)
target_include_directories(mp_metrics PUBLIC ${CMAKE_SOURCE_DIR}/include)
if (NOT WIN32)
    find_package(Threads REQUIRED)
    target_link_libraries(mp_metrics PUBLIC Threads::Threads)
endif()

# ========== Ejemplos ==========
add_executable(broker_client_example
        examples/broker_client_example.cpp
        include/MetricsAggregator.h
)
target_include_directories(broker_client_example PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(broker_client_example PRIVATE mp_brokerclient)

add_executable(metrics_stream_example
        examples/metrics_stream.cpp
)
target_include_directories(metrics_stream_example PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(metrics_stream_example PRIVATE mp_brokerclient mp_metrics)
if (WIN32)
    target_link_libraries(metrics_stream_example PRIVATE ws2_32)
endif()

# ========== Tests ==========
add_executable(test_socket tests/test_socket.cpp)
target_include_directories(test_socket PRIVATE ${CMAKE_SOURCE_DIR}/include ${LEGACY_DIR})
target_link_libraries(test_socket PRIVATE mp_common mp_tracker)

# legacy overrides para test_socket
add_library(memprof_legacy OBJECT
        ${LEGACY_DIR}/new_delete_overrides.cpp
        ${LEGACY_DIR}/registry.cpp
)
target_include_directories(memprof_legacy PRIVATE ${LEGACY_DIR})
target_compile_definitions(memprof_legacy PRIVATE MEMPROF_ENABLE_REGISTRY)
target_link_libraries(test_socket PRIVATE memprof_bridge $<TARGET_OBJECTS:memprof_legacy>)

add_library(memprof_bridge STATIC ${LEGACY_DIR}/LegacyBridge.cpp)
target_include_directories(memprof_bridge PUBLIC ${CMAKE_SOURCE_DIR}/include ${LEGACY_DIR})
target_link_libraries(memprof_bridge PUBLIC mp_common mp_tracker)

add_executable(test_metrics tests/test_metrics.cpp)
target_include_directories(test_metrics PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(test_metrics PRIVATE mp_metrics)

include(CTest)
add_test(NAME metrics_unit_test COMMAND test_metrics)

# ========== Warnings ==========
if (MSVC)
    foreach(t mp_common mp_tracker memory_profiler_server mp_brokerclient mp_metrics broker_client_example metrics_stream_example test_socket test_metrics)
        target_compile_options(${t} PRIVATE /W4 /permissive- /utf-8)
    endforeach()
else()
    foreach(t mp_common mp_tracker memory_profiler_server mp_brokerclient mp_metrics broker_client_example metrics_stream_example test_socket test_metrics)
        target_compile_options(${t} PRIVATE -Wall -Wextra -Wpedantic)
    endforeach()
endif()

# ========== Servidor HTTP de m√©tricas + est√°ticos ==========
add_executable(gui_http_server
        src/gui_http_server.cpp
        src/MetricsAggregator.cpp
)
target_include_directories(gui_http_server PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_link_libraries(gui_http_server PRIVATE mp_brokerclient mp_metrics mp_common)
if (WIN32)
    target_link_libraries(gui_http_server PRIVATE ws2_32)
else()
    find_package(Threads REQUIRED)
    target_link_libraries(gui_http_server PRIVATE Threads::Threads)
endif()




--------------------------------------------------

LegacyBridge.cpp:
-----------------
#include "LegacyBridge.h"

#include "memprof.hpp"     // eventos legacy
#include "Protocol.h"      // t√≥picos y encode
#include "MemoryTracker.h" // ProfilerClient (SDK)

#include <cstdio>
#include <string>

namespace {

    inline const char* kind_str(memprof::EventKind k) noexcept {
        return (k == memprof::EventKind::Alloc) ? "ALLOC" : "FREE";
    }

    // Ojo: esto arma JSON en un buffer de stack para evitar grandes allocs.
    inline int make_json(char* out, int cap, const memprof::Event& ev) noexcept {
        // Campos pueden ser null
        const char* file = ev.file ? ev.file : "";
        const char* type = ev.type ? ev.type : "";
        // NOTA: thread_id/timestamp_ns vienen del legacy
        return std::snprintf(out, cap,
            "{\"kind\":\"%s\",\"ptr\":\"%p\",\"size\":%zu,"
            "\"file\":\"%s\",\"line\":%d,"
            "\"type\":\"%s\",\"is_array\":%d,"
            "\"ts_ns\":%llu,\"thread\":%llu}",
            kind_str(ev.kind), ev.ptr, static_cast<size_t>(ev.size),
            file, ev.line, type, ev.is_array ? 1 : 0,
            (unsigned long long)ev.timestamp_ns,
            (unsigned long long)ev.thread_id
        );
    }

    void legacy_sink_to_broker(const memprof::Event& ev) noexcept {
        // Armar payload JSON en stack
        char json[768];
        int n = make_json(json, sizeof(json), ev);
        if (n <= 0) return;
        try {
            // Publicar al broker en el t√≥pico unificado
            // (puedes cambiar a TOPIC_ALLOCATION/DEALLOCATION si prefieres)
            ProfilerClient::instance().publish(protocol::TOPIC_MEMORY_UPDATE, std::string(json, (size_t)n));
        } catch (...) {
            // Swallow: no romper la app si hay error de red
        }
    }

} // namespace

namespace legacy_bridge {

    void install_socket_sink(const std::string& ip, unsigned short port, const std::string& appId) {
        // Configura el destino del SDK
        ProfilerClient::instance().configure(ip, port, appId);

        // Conectar legacy -> sink
        memprof::set_sink(&legacy_sink_to_broker);
    }

} // namespace legacy_bridge


--------------------------------------------------

new_delete_overrides.cpp:
-------------------------
// src/new_delete_overrides.cpp
#include <new>
#include <cstddef>
#include <cstdlib>
#include <atomic>

#if defined(_MSC_VER) || defined(__MINGW32__)
  #include <malloc.h> // _aligned_malloc, _aligned_free
#endif

#ifdef MEMPROF_ENABLE_REGISTRY
  #include "registry.hpp"
  #define MP_REG_ALLOC_SCALAR(P,SZ,FILE,LINE,TYPE) memprof::register_alloc((P),(SZ),(FILE),(LINE),(TYPE),false)
  #define MP_REG_ALLOC_ARRAY(P,SZ,FILE,LINE,TYPE)  memprof::register_alloc((P),(SZ),(FILE),(LINE),(TYPE),true)
  #define MP_REG_FREE(P)            memprof::register_free((P))
#else
  #define MP_REG_ALLOC_SCALAR(P,SZ,FILE,LINE,TYPE) ((void)0)
  #define MP_REG_ALLOC_ARRAY(P,SZ,FILE,LINE,TYPE)  ((void)0)
  #define MP_REG_FREE(P)                           ((void)0)
#endif

namespace {
// Reentrancia: si true, no registramos (evita loops cuando el registry asigna internamente)
thread_local bool mp_in_new = false;
  // --- RAII para marcar/desmarcar reentrancia de new/delete ---
  struct ReentrancyGuard {
    bool prev;
    ReentrancyGuard() noexcept : prev(mp_in_new) { mp_in_new = true; }
    ~ReentrancyGuard() { mp_in_new = prev; }
  };


// Canal de metadatos capturados por las macros/overloads de file/line/type
thread_local const char* mp_file  = nullptr;
thread_local int         mp_line  = 0;
thread_local const char* mp_type  = nullptr;

// Helpers aligned
inline void* mp_aligned_alloc(std::size_t n, std::size_t alignment) {
#if defined(_MSC_VER) || defined(__MINGW32__)
  if (alignment == 0) alignment = alignof(std::max_align_t);
  return _aligned_malloc(n, alignment);
#else
  if (alignment < sizeof(void*)) alignment = sizeof(void*);
  std::size_t p = 1; while (p < alignment) p <<= 1; alignment = p;
  std::size_t size = n;
  if (alignment && (size % alignment)) size += alignment - (size % alignment);
  void* ptr = nullptr;
  if (posix_memalign(&ptr, alignment, size) != 0) return nullptr;
  return ptr;
#endif
}
inline void mp_aligned_free(void* p) noexcept {
#if defined(_MSC_VER) || defined(__MINGW32__)
  _aligned_free(p);
#else
  std::free(p);
#endif
}

// Consume (y limpia) el contexto actual para no ‚Äúcontaminar‚Äù la siguiente asignaci√≥n
struct Ctx {
  const char* file; int line; const char* type;
};
inline Ctx consume_ctx() {
  Ctx c{ mp_file, mp_line, mp_type };
  mp_file = nullptr; mp_line = 0; mp_type = nullptr;
  return c;
}
} // anon

// ======================================================
//              new / delete (ESCALAR)
// ======================================================
void* operator new(std::size_t n) {
  if (n == 0) n = 1;

  if (mp_in_new) { // reentrante: NO registrar
    void* p = std::malloc(n);
    if (!p) throw std::bad_alloc();
    return p;
  }

  mp_in_new = true;
  void* p = std::malloc(n);
  if (!p) { mp_in_new = false; throw std::bad_alloc(); }
  auto c = consume_ctx();
  MP_REG_ALLOC_SCALAR(p, n, c.file, c.line, c.type);
  mp_in_new = false;
  return p;
}

void operator delete(void* p) noexcept {
  if (!p) return;

  if (mp_in_new) { std::free(p); return; }

  mp_in_new = true;
  MP_REG_FREE(p);
  std::free(p);
  mp_in_new = false;
}

// nothrow / sized
void* operator new(std::size_t n, const std::nothrow_t&) noexcept {
  try { return ::operator new(n); } catch (...) { return nullptr; }
}
void operator delete(void* p, const std::nothrow_t&) noexcept { ::operator delete(p); }
void operator delete(void* p, std::size_t) noexcept { ::operator delete(p); }

// ======================================================
//              new[] / delete[] (ARREGLOS)
// ======================================================
void* operator new[](std::size_t n) {
  if (n == 0) n = 1;

  if (mp_in_new) {
    void* p = std::malloc(n);
    if (!p) throw std::bad_alloc();
    return p;
  }

  mp_in_new = true;
  void* p = std::malloc(n);
  if (!p) { mp_in_new = false; throw std::bad_alloc(); }
  auto c = consume_ctx();
  MP_REG_ALLOC_ARRAY(p, n, c.file, c.line, c.type);
  mp_in_new = false;
  return p;
}

void operator delete[](void* p) noexcept {
  if (!p) return;

  if (mp_in_new) { std::free(p); return; }

  mp_in_new = true;
  MP_REG_FREE(p);
  std::free(p);
  mp_in_new = false;
}

void* operator new[](std::size_t n, const std::nothrow_t&) noexcept {
  try { return ::operator new[](n); } catch (...) { return nullptr; }
}
void operator delete[](void* p, const std::nothrow_t&) noexcept { ::operator delete[](p); }
void operator delete[](void* p, std::size_t) noexcept { ::operator delete[](p); }

// ======================================================
//          ALIGNED new / delete (C++17)
// ======================================================
void* operator new(std::size_t n, std::align_val_t al) {
  if (n == 0) n = 1;
  std::size_t alignment = static_cast<std::size_t>(al);

  if (mp_in_new) {
    void* p = mp_aligned_alloc(n, alignment);
    if (!p) throw std::bad_alloc();
    return p;
  }

  mp_in_new = true;
  void* p = mp_aligned_alloc(n, alignment);
  if (!p) { mp_in_new = false; throw std::bad_alloc(); }
  auto c = consume_ctx();
  MP_REG_ALLOC_SCALAR(p, n, c.file, c.line, c.type);
  mp_in_new = false;
  return p;
}
void operator delete(void* p, std::align_val_t al) noexcept {
  if (!p) return;
  (void)al;

  if (mp_in_new) { mp_aligned_free(p); return; }

  mp_in_new = true;
  MP_REG_FREE(p);
  mp_aligned_free(p);
  mp_in_new = false;
}

void* operator new(std::size_t n, std::align_val_t al, const std::nothrow_t&) noexcept {
  try { return ::operator new(n, al); } catch (...) { return nullptr; }
}
void operator delete(void* p, std::align_val_t al, const std::nothrow_t&) noexcept {
  ::operator delete(p, al);
}
void operator delete(void* p, std::size_t, std::align_val_t al) noexcept {
  ::operator delete(p, al);
}

// ======================================================
//        ALIGNED new[] / delete[] (C++17)
// ======================================================
void* operator new[](std::size_t n, std::align_val_t al) {
  if (n == 0) n = 1;
  std::size_t alignment = static_cast<std::size_t>(al);

  if (mp_in_new) {
    void* p = mp_aligned_alloc(n, alignment);
    if (!p) throw std::bad_alloc();
    return p;
  }

  mp_in_new = true;
  void* p = mp_aligned_alloc(n, alignment);
  if (!p) { mp_in_new = false; throw std::bad_alloc(); }
  auto c = consume_ctx();
  MP_REG_ALLOC_ARRAY(p, n, c.file, c.line, c.type);
  mp_in_new = false;
  return p;
}
void operator delete[](void* p, std::align_val_t al) noexcept {
  if (!p) return;
  (void)al;

  if (mp_in_new) { mp_aligned_free(p); return; }

  mp_in_new = true;
  MP_REG_FREE(p);
  mp_aligned_free(p);
  mp_in_new = false;
}
void* operator new[](std::size_t n, std::align_val_t al, const std::nothrow_t&) noexcept {
  try { return ::operator new[](n, al); } catch (...) { return nullptr; }
}
void operator delete[](void* p, std::align_val_t al, const std::nothrow_t&) noexcept {
  ::operator delete[](p, al);
}
void operator delete[](void* p, std::size_t, std::align_val_t al) noexcept {
  ::operator delete[](p, al);
}

// ======================================================
//  Overloads ‚Äúplacement-like‚Äù para capturar file/line/type
//  usadas por las macros del header p√∫blico
// ======================================================
#ifdef MEMPROF_ENABLE_REGISTRY
#define MP_REG_ALLOC_META(P,SZ,FILE,LINE,TYPE,ISARR) \
memprof::register_alloc((P),(SZ),(FILE),(LINE),(TYPE),(ISARR))
#else
#define MP_REG_ALLOC_META(...) ((void)0)
#endif

// --- Captura file/line (escalares/arrays) ---
void* operator new(std::size_t n, const char* file, int line) {
  if (n == 0) n = 1;
  ReentrancyGuard g;
  void* p = std::malloc(n);
  if (!p) throw std::bad_alloc();
  MP_REG_ALLOC_META(p, n, file, line, nullptr, false);
  return p;
}

void* operator new[](std::size_t n, const char* file, int line) {
  if (n == 0) n = 1;
  ReentrancyGuard g;
  void* p = std::malloc(n);
  if (!p) throw std::bad_alloc();
  MP_REG_ALLOC_META(p, n, file, line, nullptr, true);
  return p;
}

// --- Captura file/line/type (escalares/arrays) ---
void* operator new(std::size_t n, const char* file, int line, const char* type) {
  if (n == 0) n = 1;
  ReentrancyGuard g;
  void* p = std::malloc(n);
  if (!p) throw std::bad_alloc();
  MP_REG_ALLOC_META(p, n, file, line, type, false);
  return p;
}

void* operator new[](std::size_t n, const char* file, int line, const char* type) {
  if (n == 0) n = 1;
  ReentrancyGuard g;
  void* p = std::malloc(n);
  if (!p) throw std::bad_alloc();
  MP_REG_ALLOC_META(p, n, file, line, type, true);
  return p;
}



--------------------------------------------------

registry.cpp:
-------------
#include "registry.hpp"
#include "memprof.hpp"

#include <atomic>
#include <mutex>
#include <unordered_map>
#include <chrono>
#include <thread>
#include <cstdio>

namespace {

using clock_t = std::chrono::steady_clock;

inline std::uint64_t now_ns() noexcept {
    return std::chrono::duration_cast<std::chrono::nanoseconds>(
        clock_t::now().time_since_epoch()).count();
}

inline std::uint64_t thread_id_u64() noexcept {
    auto id = std::this_thread::get_id();
    // hash estable suficiente para m√©tricas
    return std::hash<std::thread::id>{}(id);
}

struct State {
    std::unordered_map<void*, memprof::AllocInfo> live;
    std::mutex mtx;

    std::atomic<std::uint64_t> bytes_current{0};
    std::atomic<std::uint64_t> bytes_peak{0};
    std::atomic<std::uint64_t> allocs_total{0};
    std::atomic<std::uint64_t> allocs_active{0};
    std::atomic<std::uint64_t> idgen{1};

    memprof::Sink sink{nullptr};

    void update_peak(std::uint64_t cur) {
        auto old = bytes_peak.load(std::memory_order_relaxed);
        while (cur > old &&
               !bytes_peak.compare_exchange_weak(old, cur, std::memory_order_relaxed)) { /* spin */ }
    }
};

State& S() {
    static State s;
    return s;
}

} // anon

namespace memprof {

void set_sink(Sink s) noexcept {
    S().sink = s;
}

void register_alloc(void* p,
                    std::size_t size,
                    const char* file,
                    int line,
                    const char* type,
                    bool is_array) noexcept
{
    if (!p) return;
    auto& st = S();
    const auto tns = now_ns();
    const auto tid = thread_id_u64();
    const auto id  = st.idgen.fetch_add(1, std::memory_order_relaxed);

    {
        std::lock_guard<std::mutex> lk(st.mtx);
        AllocInfo ai;
        ai.size        = size;
        ai.file        = file;
        ai.line        = line;
        ai.type        = type;
        ai.timestamp_ns= tns;
        ai.id          = id;
        ai.is_array    = is_array;
        ai.thread_id   = tid;
        st.live[p] = ai;
    }

    const auto cur = st.bytes_current.fetch_add(size, std::memory_order_relaxed) + size;
    st.update_peak(cur);
    st.allocs_total.fetch_add(1, std::memory_order_relaxed);
    st.allocs_active.fetch_add(1, std::memory_order_relaxed);

    if (st.sink) {
        Event ev{ EventKind::Alloc, p, size, type, file, line, tns, is_array, tid };
        st.sink(ev);
    }
}

void register_free(void* p) noexcept {
    if (!p) return;
    auto& st = S();

    std::size_t freed = 0;
    const char* file = nullptr;
    int line = 0;
    const char* type = nullptr;
    bool is_array = false;
    std::uint64_t tns = now_ns();
    std::uint64_t tid = thread_id_u64();

    {
        std::lock_guard<std::mutex> lk(st.mtx);
        auto it = st.live.find(p);
        if (it != st.live.end()) {
            freed    = it->second.size;
            file     = it->second.file;
            line     = it->second.line;
            type     = it->second.type;
            is_array = it->second.is_array;
            st.live.erase(it);
        }
    }

    if (freed) {
        st.bytes_current.fetch_sub(freed, std::memory_order_relaxed);
        st.allocs_active.fetch_sub(1, std::memory_order_relaxed);
    }

    if (st.sink) {
        Event ev{ EventKind::Free, p, freed, type, file, line, tns, is_array, tid };
        st.sink(ev);
    }
}

// M√©tricas
std::uint64_t current_bytes() noexcept { return S().bytes_current.load(std::memory_order_relaxed); }
std::uint64_t peak_bytes()    noexcept { return S().bytes_peak.load(std::memory_order_relaxed); }
std::uint64_t total_allocs()  noexcept { return S().allocs_total.load(std::memory_order_relaxed); }
std::uint64_t active_allocs() noexcept { return S().allocs_active.load(std::memory_order_relaxed); }

// Dump de fugas
void dump_leaks_to_stdout() noexcept {
    auto& st = S();
    std::lock_guard<std::mutex> lk(st.mtx);
    if (st.live.empty()) {
        std::printf("[memprof] No leaks.\n");
        return;
    }
    std::printf("[memprof] Leaks (%zu):\n", st.live.size());
    for (const auto& [ptr, ai] : st.live) {
        std::printf("  ptr=%p size=%zu file=%s line=%d type=%s ts=%llu %s\n",
            ptr, ai.size,
            ai.file ? ai.file : "(?)",
            ai.line,
            ai.type ? ai.type : "(?)",
            (unsigned long long)ai.timestamp_ns,
            ai.is_array ? "[array]" : "[scalar]"
        );
    }
}

} // namespace memprof


--------------------------------------------------

broker_client_example.cpp:
--------------------------
#include <iostream>
#include "BrokerClient.h"

int main() {
    BrokerClient client;
    client.configure("127.0.0.1", 5000, "TEST-GUI");

    if (!client.connect()) {
        std::cerr << "Error conectando al broker\n";
        return 1;
    }
    if (!client.subscribe("MEMORY_UPDATE")) {
        std::cerr << "Error suscribi√©ndose\n";
        return 1;
    }

    std::cout << "Esperando 10 eventos...\n";
    for (int i = 0; i < 10; ++i) {
        std::string json = client.receiveEvent();
        if (json.empty()) {
            std::cerr << "Conexi√≥n cerrada o error al recibir.\n";
            break;
        }
        std::cout << "Evento " << i << ": " << json << "\n";
    }

    client.disconnect();
    return 0;
}


--------------------------------------------------

metrics_stream.cpp:
-------------------
#include <iostream>
#include <chrono>
#include <thread>

#include "BrokerClient.h"
#include "MetricsCalculator.h"

int main() {
    BrokerClient client;
    client.configure("127.0.0.1", 5000, "GUI-METRICS");
    if (!client.connect()) {
        std::cerr << "[metrics_stream] No se pudo conectar al broker.\n";
        return 1;
    }
    if (!client.subscribe("MEMORY_UPDATE")) {
        std::cerr << "[metrics_stream] Fall√≥ la suscripci√≥n a MEMORY_UPDATE.\n";
        return 1;
    }

    MetricsCalculator calc;
    calc.setLeakThresholdMs(30000); // 30s por defecto

    std::cout << "[metrics_stream] Esperando eventos...\n";

    uint64_t count = 0;
    const uint64_t print_every = 50; // imprime cada 50 eventos

    while (client.isConnected()) {
        std::string ev = client.receiveEvent(); // bloqueante
        if (ev.empty()) {
            std::cerr << "[metrics_stream] Conexi√≥n cerrada o error recibiendo.\n";
            break;
        }
        calc.processEvent(ev);
        if (++count % print_every == 0) {
            auto snap = calc.getSnapshot();
            std::cout << "[metrics_stream] " << snap.toJSON() << "\n";
        }
    }

    return 0;
}


--------------------------------------------------

app.js:
-------
import { lineChart, barChart, pieChart } from './charts.js';

/* =================== Config =================== */
const POLL_MS = 300;                 // 200‚Äì500 ms
const REQ_TIMEOUT_MS = 1200;
const LEAK_THRESHOLD_MS = 30000;     // Debe coincidir con backend (por defecto 30s)
document.getElementById('leak-th-ms').textContent = LEAK_THRESHOLD_MS.toString();

/* =============== Helpers generales =============== */
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));

function bytesToMB(b){ return (b / (1024*1024)); }
function fmtMB(b){ return bytesToMB(b).toFixed(2) + ' MB'; }
function fmtPct(x){ return (x*100).toFixed(2) + '%'; }
function safe(obj, path, dflt){ try{ return path.split('.').reduce((o,k)=>o[k], obj) ?? dflt; }catch{ return dflt; } }

async function fetchJSON(path){
    const ctl = new AbortController();
    const t = setTimeout(()=>ctl.abort(), REQ_TIMEOUT_MS);
    try{
        const r = await fetch(path, {signal: ctl.signal, cache: 'no-store'});
        if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
        return await r.json();
    } finally { clearTimeout(t); }
}

function setStatus(ok){
    const el = $('#status-badge');
    if (ok){ el.textContent = 'En l√≠nea'; el.className = 'badge badge-ok'; }
    else { el.textContent = 'Conectando‚Ä¶'; el.className = 'badge badge-warn'; }
}

/* =============== Tabs accesibles =============== */
function setupTabs(){
    const tabs = $$('.tab');
    const panes = $$('.tabpane');
    tabs.forEach(btn=>{
        btn.addEventListener('click', ()=>{
            tabs.forEach(b=>{ b.classList.remove('active'); b.setAttribute('aria-selected','false'); });
            panes.forEach(p=>p.classList.remove('active'));
            btn.classList.add('active'); btn.setAttribute('aria-selected','true');
            const pane = $('#'+btn.getAttribute('aria-controls'));
            pane.classList.add('active');

            // üîÅ Re-render del tab activo (por si estuvo oculto y los canvas ten√≠an w=0)
            if (pane.id === 'tab-general') {
                renderTimeline(lastTimeline);
            } else if (pane.id === 'tab-archivo') {
                renderFileTable(lastFileStats);
            } else if (pane.id === 'tab-leaks') {
                renderLeaksCharts();
            }
            // (Mapa es tabla; no necesita redibujar canvas)
        });
    });
}

// Redibuja lo visible si el usuario cambia el tama√±o de la ventana
window.addEventListener('resize', ()=>{
    const active = $('.tabpane.active')?.id;
    if (active === 'tab-general') renderTimeline(lastTimeline);
    else if (active === 'tab-archivo') renderFileTable(lastFileStats);
    else if (active === 'tab-leaks') renderLeaksCharts();
});

/* =============== Estado in-memory (UI) =============== */
let lastTimeline = []; // [{t_ns,current_bytes,leak_bytes}]
let lastBlocks = [];   // cache para edades/estados
let lastFileStats = {}; // {file: {alloc_count,alloc_bytes,live_count,live_bytes}}
let lastLeaks = {};     // KPIs para leaks

/* =============== Render: GENERAL =============== */
function renderKPIs(metrics){
    $('#kpi-current').textContent = fmtMB(metrics.current_bytes||0);
    $('#kpi-active').textContent  = (metrics.active_allocs||0).toString();
    $('#kpi-leaks').textContent   = fmtMB(metrics.leak_bytes||0);
    $('#kpi-peak').textContent    = fmtMB(metrics.peak_bytes||0);
    $('#kpi-total').textContent   = (metrics.total_allocs||0).toString();
}

function renderTimeline(timeline){
    // Guardamos para la pesta√±a de leaks tambi√©n
    lastTimeline = timeline || [];
    const curMB = lastTimeline.map(p=> bytesToMB(p.current_bytes||0));
    const lkMB  = lastTimeline.map(p=> bytesToMB(p.leak_bytes||0));
    const canvas = $('#chart-timeline');
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    lineChart(canvas, null, [
        { name:'current', values: curMB },
        { name:'leaks',   values: lkMB  },
    ]);
}

function renderTop3(fileStats){
    // fileStats: obj -> array ordenada por live_bytes desc
    const rows = Object.entries(fileStats)
        .map(([file,st])=>({file, ...st}))
        .sort((a,b)=> (b.live_bytes||0)-(a.live_bytes||0))
        .slice(0,3);
    const tbody = $('#tbl-top3'); tbody.innerHTML = '';
    rows.forEach(r=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td title="${r.file}">${r.file}</td>
                    <td>${r.alloc_count}</td>
                    <td>${bytesToMB(r.live_bytes).toFixed(2)}</td>`;
        tbody.appendChild(tr);
    });
}

/* =============== Render: MAPA =============== */
function classifyBlockAge(ts_ns){
    const now_ns = BigInt(Date.now()) * 1000000n;
    const age_ms = Number( (now_ns - BigInt(ts_ns||0)) / 1000000n );
    let state = 'normal';
    if (age_ms > LEAK_THRESHOLD_MS*2) state = 'posible leak';
    else if (age_ms > LEAK_THRESHOLD_MS) state = 'envejecido';
    return {age_ms, state};
}
function renderBlocks(blocks){
    lastBlocks = blocks || [];
    // Orden
    const sel = $('#blocks-sort').value;
    const arr = [...lastBlocks];
    if (sel==='ts_desc') arr.sort((a,b)=> (b.ts_ns||0)-(a.ts_ns||0));
    else if (sel==='size_desc') arr.sort((a,b)=> (b.size||0)-(a.size||0));
    else if (sel==='size_asc') arr.sort((a,b)=> (a.size||0)-(b.size||0));

    const tbody = $('#tbl-blocks'); tbody.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (const b of arr){
        const {age_ms, state} = classifyBlockAge(b.ts_ns);
        const badgeCls = state==='posible leak' ? 'badge badge-danger'
            : state==='envejecido'   ? 'badge badge-warn'
                : 'badge';
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td>${b.ptr}</td>
      <td>${b.size}</td>
      <td>${bytesToMB(b.size).toFixed(2)}</td>
      <td>${b.file || ''}${b.line? ':'+b.line:''}</td>
      <td>${b.type || ''}</td>
      <td>${age_ms}</td>
      <td><span class="${badgeCls}">${state}</span></td>`;
        frag.appendChild(tr);
    }
    tbody.appendChild(frag);
}

/* =============== Render: POR ARCHIVO =============== */
function renderFileTable(fileStats){
    lastFileStats = fileStats || {};
    const rows = Object.entries(lastFileStats)
        .map(([file,st])=>({file, ...st}))
        .sort((a,b)=> (b.alloc_bytes||0)-(a.alloc_bytes||0));

    const tbody = $('#tbl-files'); tbody.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (const r of rows){
        const tr = document.createElement('tr');
        tr.innerHTML = `<td title="${r.file}">${r.file}</td>
                    <td>${r.alloc_count}</td>
                    <td>${bytesToMB(r.alloc_bytes).toFixed(2)}</td>
                    <td>${r.live_count}</td>
                    <td>${bytesToMB(r.live_bytes).toFixed(2)}</td>`;
        frag.appendChild(tr);
    }
    tbody.appendChild(frag);

    // Chart (Top N)
    const N = Math.max(3, Math.min(50, parseInt($('#sel-topN').value||'10',10)));
    const top = rows.slice(0,N);
    const labels = top.map(r=>r.file.split('/').pop());
    const series = [
        { name:'Conteo', values: top.map(r=>r.alloc_count||0) },
        { name:'MB',     values: top.map(r=>bytesToMB(r.alloc_bytes||0)) },
    ];
    const canvas = $('#chart-files');
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    barChart(canvas, labels, series, { stacked:false });
}

/* =============== Render: LEAKS =============== */
function renderLeaksKPIs(leaks){
    lastLeaks = leaks || {};
    $('#kpi-lk-total').textContent = fmtMB(leaks.total_leak_bytes||0);
    const largest = leaks.largest || {};
    $('#kpi-lk-largest').textContent = largest.size ? `${largest.ptr || '‚Äî'} (${largest.file || '‚Äî'}) ¬∑ ${fmtMB(largest.size)}` : '‚Äî';
    const topf = leaks.top_file_by_leaks || {};
    $('#kpi-lk-topfile').textContent = topf.file ? `${topf.file} ¬∑ ${topf.count||0} ¬∑ ${fmtMB(topf.bytes||0)}` : '‚Äî';
    $('#kpi-lk-rate').textContent = fmtPct(leaks.leak_rate || 0);
}
function renderLeaksCharts(){
    // Usamos file-stats para estimar "fugas por archivo" a partir de bloques vivos envejecidos
    const leakPerFile = new Map(); // file -> bytes (solo envejecidos)
    for (const b of (lastBlocks||[])) {
        const {age_ms} = classifyBlockAge(b.ts_ns);
        if (age_ms > LEAK_THRESHOLD_MS) {
            leakPerFile.set(b.file || '(desconocido)', (leakPerFile.get(b.file || '(desconocido)')||0) + (b.size||0));
        }
    }
    const entries = Array.from(leakPerFile.entries()).sort((a,b)=>b[1]-a[1]);
    const labels = entries.map(e=> e[0].split('/').pop());
    const valuesB = entries.map(e=> e[1]);

    // Barras (bytes)
    const bars = $('#chart-leaks-bars');
    bars.getContext('2d').clearRect(0,0,bars.width,bars.height);
    barChart(bars, labels, [{name:'bytes', values: valuesB}], { stacked:false });

    // Pie
    const pie = $('#chart-leaks-pie');
    pie.getContext('2d').clearRect(0,0,pie.width,pie.height);
    pieChart(pie, valuesB, labels, {});

    // Temporal: leak_bytes de timeline
    const line = $('#chart-leaks-time');
    line.getContext('2d').clearRect(0,0,line.width,line.height);
    const lkMB = (lastTimeline||[]).map(p=> bytesToMB(p.leak_bytes||0));
    lineChart(line, null, [{name:'leaks', values: lkMB}]);
}

/* =============== Polling & loop =============== */
let pollTimer = null;
let consecutiveErrors = 0;

async function pollOnce(){
    try{
        const [metrics, timeline, blocks, fileStats, leaks] = await Promise.all([
            fetchJSON('/metrics'),
            fetchJSON('/timeline'),
            fetchJSON('/blocks'),
            fetchJSON('/file-stats'),
            fetchJSON('/leaks')
        ]);

        setStatus(true); consecutiveErrors = 0;

        // GENERAL
        renderKPIs(metrics);
        renderTimeline(timeline);
        renderTop3(fileStats);

        // MAPA
        renderBlocks(blocks);

        // POR ARCHIVO
        renderFileTable(fileStats);

        // LEAKS
        renderLeaksKPIs(leaks);
        renderLeaksCharts();

    } catch(e){
        consecutiveErrors++;
        if (consecutiveErrors >= 2) setStatus(false);
        // backoff leve opcional
    }
}

function startPolling(){
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(pollOnce, POLL_MS);
}

/* =============== Arranque =============== */
window.addEventListener('load', ()=>{
    setupTabs();
    $('#blocks-sort').addEventListener('change', ()=> renderBlocks(lastBlocks));
    $('#sel-topN').addEventListener('change', ()=> renderFileTable(lastFileStats));
    startPolling();
    pollOnce();
});


--------------------------------------------------

charts.js:
----------
/* Peque√±o helper para <canvas> sin librer√≠as externas.
   Funciones: lineChart(ctx, dataX[], series[], opts), barChart(ctx, labels[], series[], opts), pieChart(ctx, values[], labels[], opts)
   - No estilos de color fijos; usa colores por defecto del contexto (configurados por caller).
*/

function fitRange(vals) {
    if (!vals.length) return {min:0, max:1};
    let mn = Math.min(...vals), mx = Math.max(...vals);
    if (mn === mx) { mn -= 1; mx += 1; }
    return {min: mn, max: mx};
}
function mapY(v, min, max, h, pad){ return h - pad - ((v - min) / (max - min)) * (h - 2*pad); }
function mapX(i, n, w, pad){ if (n<=1) return pad; return pad + i*( (w-2*pad)/(n-1) ); }

// ---------- helper de tama√±o robusto (tab oculto, etc.) ----------
function sizeCanvas(canvas) {
    const parent = canvas.parentElement;
    const measuredW = canvas.clientWidth || (parent ? parent.clientWidth : 0) || canvas.width || 300;
    const measuredH = canvas.clientHeight || canvas.height || 200;
    canvas.width  = measuredW;
    canvas.height = measuredH;
    return { w: canvas.width, h: canvas.height };
}

export function lineChart(canvas, dataX, series, opts={}){
    const ctx = canvas.getContext('2d');

    // Tama√±o robusto
    const { w, h } = sizeCanvas(canvas);
    const pad = 28;

    // X normalizado (indices) y Y en MB
    const yVals = [];
    for (const s of series) for (const v of s.values) yVals.push(v);
    const {min, max} = fitRange(yVals);

    // Limpia y Grid
    ctx.clearRect(0,0,w,h);
    ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
    for (let gy=0; gy<5; ++gy){
        const y = pad + gy*((h-2*pad)/4);
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
    }

    // Ejes
    ctx.strokeStyle = '#9ca3af';
    ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, h-pad); ctx.lineTo(w-pad, h-pad); ctx.stroke();

    // Series
    const colors = opts.colors || ['#3b82f6','#ef4444','#10b981','#f59e0b'];
    series.forEach((s, si) => {
        ctx.strokeStyle = colors[si % colors.length];
        ctx.lineWidth = 2; ctx.beginPath();
        s.values.forEach((v, i) => {
            const x = mapX(i, s.values.length, w, pad);
            const y = mapY(v, min, max, h, pad);
            if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        ctx.stroke();
    });
}

export function barChart(canvas, labels, series, opts={}){
    const ctx = canvas.getContext('2d');

    // Tama√±o robusto
    const { w, h } = sizeCanvas(canvas);
    const pad = 28; const catW = (w - 2*pad) / Math.max(1, labels.length);
    const colors = opts.colors || ['#3b82f6','#10b981','#ef4444','#f59e0b'];
    const stacked = !!opts.stacked;

    // calcular rango
    const sums = labels.map((_,i)=> series.reduce((a,s)=>a+(s.values[i]||0),0));
    const yVals = stacked ? sums : series.flatMap(s=>s.values);
    const {min, max} = fitRange(yVals);

    // Limpia y Grid
    ctx.clearRect(0,0,w,h);
    ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
    for (let gy=0; gy<5; ++gy){
        const y = pad + gy*((h-2*pad)/4);
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
    }
    ctx.strokeStyle = '#9ca3af';
    ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, h-pad); ctx.lineTo(w-pad, h-pad); ctx.stroke();

    // Barras
    labels.forEach((_, i) => {
        if (stacked){
            let acc = 0;
            series.forEach((s, si) => {
                const val = s.values[i]||0;
                const y0 = mapY(acc, min, max, h, pad);
                const y1 = mapY(acc+val, min, max, h, pad);
                const x = pad + i*catW + catW*0.1;
                const bw = catW*0.8;
                ctx.fillStyle = colors[si % colors.length];
                ctx.fillRect(x, y1, bw, y0 - y1);
                acc += val;
            });
        } else {
            const bw = (catW*0.8) / Math.max(1, series.length);
            series.forEach((s, si) => {
                const val = s.values[i]||0;
                const y0 = mapY(0, min, max, h, pad);
                const y1 = mapY(val, min, max, h, pad);
                const x = pad + i*catW + catW*0.1 + si*bw;
                ctx.fillStyle = colors[si % colors.length];
                ctx.fillRect(x, y1, bw, y0 - y1);
            });
        }
    });
}

export function pieChart(canvas, values, labels, opts={}){
    const ctx = canvas.getContext('2d');

    // Tama√±o robusto
    const { w, h } = sizeCanvas(canvas);
    ctx.clearRect(0,0,w,h);

    const colors = opts.colors || ['#3b82f6','#10b981','#ef4444','#f59e0b','#8b5cf6','#06b6d4','#84cc16','#f97316'];
    const sum = values.reduce((a,b)=>a+b,0) || 1;
    const cx = w/2, cy = h/2, r = Math.min(w,h)*0.38;
    let start = -Math.PI/2;
    values.forEach((v, i) => {
        const ang = (v/sum)*Math.PI*2;
        ctx.beginPath(); ctx.moveTo(cx,cy);
        ctx.fillStyle = colors[i % colors.length];
        ctx.arc(cx,cy,r,start,start+ang,false); ctx.closePath(); ctx.fill();
        start += ang;
    });
    // anillo
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
}


--------------------------------------------------

index.html:
-----------
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>Memory Profiler ‚Äî GUI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="style.css" />
</head>
<body>
<header class="app-header">
    <h1>Memory Profiler</h1>
    <div id="status-badge" class="badge badge-warn" aria-live="polite">Conectando‚Ä¶</div>
</header>

<nav class="tabs" role="tablist" aria-label="Pesta√±as de la aplicaci√≥n">
    <button class="tab active" role="tab" aria-selected="true" aria-controls="tab-general" id="tabbtn-general">General</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-mapa" id="tabbtn-mapa">Mapa</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-archivo" id="tabbtn-archivo">Por archivo</button>
    <button class="tab" role="tab" aria-selected="false" aria-controls="tab-leaks" id="tabbtn-leaks">Leaks</button>
</nav>

<main class="tabpanes">
    <!-- GENERAL -->
    <section id="tab-general" class="tabpane active" role="tabpanel" aria-labelledby="tabbtn-general">
        <div class="cards">
            <div class="card"><div class="kpi-title">Uso actual</div><div id="kpi-current" class="kpi-value">0.00 MB</div></div>
            <div class="card"><div class="kpi-title">Activas</div><div id="kpi-active" class="kpi-value">0</div></div>
            <div class="card"><div class="kpi-title">Fugas</div><div id="kpi-leaks" class="kpi-value">0.00 MB</div></div>
            <div class="card"><div class="kpi-title">Pico</div><div id="kpi-peak" class="kpi-value">0.00 MB</div></div>
            <div class="card"><div class="kpi-title">Total allocs</div><div id="kpi-total" class="kpi-value">0</div></div>
        </div>

        <div class="panel">
            <div class="panel-head">
                <h2>L√≠nea de tiempo</h2>
                <div class="legend"><span class="dot"></span> Memoria (MB) ‚Äî <span class="dot dot2"></span> Leak (MB)</div>
            </div>
            <canvas id="chart-timeline" height="180"></canvas>
        </div>

        <div class="panel">
            <div class="panel-head">
                <h2>Top-3 por archivo</h2>
            </div>
            <div class="table-wrap">
                <table class="zebra">
                    <thead><tr><th>Archivo</th><th>Conteo</th><th>MB</th></tr></thead>
                    <tbody id="tbl-top3"></tbody>
                </table>
            </div>
        </div>
    </section>

    <!-- MAPA -->
    <section id="tab-mapa" class="tabpane" role="tabpanel" aria-labelledby="tabbtn-mapa">
        <div class="panel">
            <div class="panel-head">
                <h2>Bloques vivos</h2>
                <div class="actions">
                    <label>Ordenar:
                        <select id="blocks-sort">
                            <option value="ts_desc">M√°s recientes</option>
                            <option value="size_desc">Tama√±o (desc)</option>
                            <option value="size_asc">Tama√±o (asc)</option>
                        </select>
                    </label>
                </div>
            </div>
            <div class="table-wrap">
                <table class="zebra">
                    <thead>
                    <tr>
                        <th>Ptr</th><th>Size (B)</th><th>Size (MB)</th><th>file:line</th><th>type</th><th>edad (ms)</th><th>estado</th>
                    </tr>
                    </thead>
                    <tbody id="tbl-blocks"></tbody>
                </table>
            </div>
            <div class="hint">Regla: <span class="badge">normal</span> &middot; <span class="badge badge-warn">envejecido</span> &middot; <span class="badge badge-danger">posible leak</span></div>
        </div>
    </section>

    <!-- POR ARCHIVO -->
    <section id="tab-archivo" class="tabpane" role="tabpanel" aria-labelledby="tabbtn-archivo">
        <div class="panel">
            <div class="panel-head">
                <h2>Estad√≠sticas por archivo</h2>
                <div class="actions">
                    <label>Top N:
                        <input type="number" id="sel-topN" min="3" max="50" value="10" />
                    </label>
                </div>
            </div>
            <div class="table-wrap">
                <table class="zebra">
                    <thead>
                    <tr><th>Archivo</th><th>alloc_count</th><th>alloc_MB</th><th>live_count</th><th>live_MB</th></tr>
                    </thead>
                    <tbody id="tbl-files"></tbody>
                </table>
            </div>
        </div>

        <div class="panel">
            <div class="panel-head"><h2>Barras ‚Äî Conteo vs MB</h2></div>
            <canvas id="chart-files" height="220"></canvas>
        </div>
    </section>

    <!-- LEAKS -->
    <section id="tab-leaks" class="tabpane" role="tabpanel" aria-labelledby="tabbtn-leaks">
        <div class="cards">
            <div class="card"><div class="kpi-title">Total fugado</div><div id="kpi-lk-total" class="kpi-value">0.00 MB</div></div>
            <div class="card"><div class="kpi-title">Leak m√°s grande</div><div id="kpi-lk-largest" class="kpi-value">‚Äî</div></div>
            <div class="card"><div class="kpi-title">Top archivo por leaks</div><div id="kpi-lk-topfile" class="kpi-value">‚Äî</div></div>
            <div class="card"><div class="kpi-title">Leak rate</div><div id="kpi-lk-rate" class="kpi-value">0.00%</div></div>
        </div>

        <div class="grid-2">
            <div class="panel">
                <div class="panel-head"><h2>Fugas por archivo (bytes)</h2></div>
                <canvas id="chart-leaks-bars" height="220"></canvas>
            </div>
            <div class="panel">
                <div class="panel-head"><h2>Distribuci√≥n de fugas</h2></div>
                <canvas id="chart-leaks-pie" height="220"></canvas>
            </div>
        </div>

        <div class="panel">
            <div class="panel-head"><h2>Leak bytes en el tiempo</h2></div>
            <canvas id="chart-leaks-time" height="180"></canvas>
        </div>
    </section>
</main>

<footer class="app-footer">
    <span>Polling ~300 ms</span>
    <span>Umbral leak: <code id="leak-th-ms">30000</code> ms</span>
</footer>

<script type="module" src="app.js"></script>

</body>
</html>


--------------------------------------------------

style.css:
----------
:root{
    --bg:#f7f7fb;
    --fg:#1d1e22;
    --muted:#6b7280;
    --card:#ffffff;
    --border:#e5e7eb;
    --accent:#3b82f6;
    --warn:#f59e0b;
    --danger:#ef4444;
    --ok:#10b981;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
    margin:0;
    font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    background:var(--bg);
    color:var(--fg);
}

.app-header{
    display:flex; align-items:center; justify-content:space-between;
    padding:10px 16px; background:#fff; border-bottom:1px solid var(--border);
    position:sticky; top:0; z-index:5;
}
h1{font-size:18px; margin:0}

.badge{
    display:inline-block; padding:2px 8px; border-radius:999px; background:#e5e7eb; color:#111; font-weight:600
}
.badge-warn{ background:rgba(245,158,11,.15); color:#92400e; }
.badge-danger{ background:rgba(239,68,68,.15); color:#991b1b; }
.badge-ok{ background:rgba(16,185,129,.15); color:#065f46; }

.tabs{
    display:flex; gap:8px; padding:8px 12px; background:#fff; border-bottom:1px solid var(--border);
}
.tab{
    border:1px solid var(--border); background:var(--card); border-radius:8px;
    padding:8px 12px; cursor:pointer; font-weight:600; color:#374151;
}
.tab.active{ border-color:var(--accent); color:#111; box-shadow:0 0 0 2px rgba(59,130,246,.1) inset; }

.tabpanes{ padding:12px; max-width:1200px; margin:0 auto; }
.tabpane{ display:none; }
.tabpane.active{ display:block; }

.cards{
    display:grid; grid-template-columns:repeat(5,1fr); gap:12px; margin-bottom:12px;
}
@media (max-width:1000px){ .cards{ grid-template-columns:repeat(3,1fr); } }
@media (max-width:700px){ .cards{ grid-template-columns:repeat(2,1fr); } }
@media (max-width:480px){ .cards{ grid-template-columns:1fr; } }

.card{
    background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px;
}
.kpi-title{ color:var(--muted); font-size:12px; margin-bottom:6px; }
.kpi-value{ font-size:20px; font-weight:800; }

.panel{
    background:var(--card); border:1px solid var(--border); border-radius:12px; padding:10px; margin:12px 0;
}
.panel-head{
    display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px;
}
.panel h2{ margin:4px 0; font-size:16px; }

.legend{ color:var(--muted); font-size:12px; }
.legend .dot{ display:inline-block; width:10px; height:10px; border-radius:2px; background:var(--accent); margin:0 6px 0 2px; vertical-align:middle; }
.legend .dot2{ background:var(--danger); }

.table-wrap{ overflow:auto; max-height:60vh; }
table{ border-collapse:collapse; width:100%; }
th, td{ padding:8px 10px; border-bottom:1px solid var(--border); white-space:nowrap; }
thead th{ position:sticky; top:0; background:#fff; z-index:2; }
.zebra tbody tr:nth-child(odd){ background:#fafafa; }

.actions{ color:var(--muted); font-size:12px; display:flex; gap:12px; align-items:center; }
.actions input, .actions select{ padding:4px 6px; border:1px solid var(--border); border-radius:6px; background:#fff; }

.grid-2{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
@media (max-width:900px){ .grid-2{ grid-template-columns:1fr; } }

.app-footer{
    padding:10px 16px; display:flex; gap:12px; justify-content:space-between;
    color: var(--muted);                  /* ‚úÖ corregido */
    border-top:1px solid var(--border); background:#fff; position:sticky; bottom:0;
}

.hint{ color:var(--muted); font-size:12px; margin-top:6px; }
code{ background:#eef2ff; padding:2px 6px; border-radius:6px; }

/* ‚úÖ Asegura que el <canvas> crezca con su contenedor y repinte a tama√±o real */
canvas { width: 100%; display: block; }


--------------------------------------------------

BrokerClient.h:
---------------
#pragma once
#include <string>
#include <atomic>
#include <mutex>
#include "NetUtils.h"

class BrokerClient {
public:
    BrokerClient();
    ~BrokerClient();

    // Configuraci√≥n
    void configure(const std::string& host, uint16_t port, const std::string& appId);

    // Conexi√≥n y suscripci√≥n
    bool connect();
    bool subscribe(const std::string& topic);
    void disconnect();

    // Recepci√≥n de eventos (bloquea hasta recibir una l√≠nea)
    // Retorna el JSON (payload) o string vac√≠o si hay error/desconexi√≥n.
    std::string receiveEvent();

    // Estado
    bool isConnected() const;

private:
    socket_t sock_;
    std::string host_;
    uint16_t port_;
    std::string appId_;
    std::atomic<bool> connected_;
    mutable std::mutex mtx_;
    net::WSAInit wsa_; // RAII (no-op en Linux)

    // Helpers internos (NO reimplementan utilidades, solo orquestan)
    bool sendLineLocked_(const std::string& line);
    bool recvLineLocked_(std::string& out);
};


--------------------------------------------------

LegacyBridge.h:
---------------
#pragma once
#include <string>

namespace legacy_bridge {

    // Configura el destino (broker) e instala el sink de legacy.
    // Llama a esto al inicio de la app que quieras perfilar (NO el servidor).
    void install_socket_sink(const std::string& ip, unsigned short port, const std::string& appId);

} // namespace legacy_bridge


--------------------------------------------------

MemoryTracker.h:
----------------
#pragma once
#include <string>
#include <mutex>
#include "Protocol.h"
#include "NetUtils.h"

class ProfilerClient {
public:
    static ProfilerClient& instance();

    // Configura destino y appId. Cierra la conexi√≥n previa si exist√≠a.
    void configure(const std::string& ip, uint16_t port, const std::string& appId);

    // Publica usando una conexi√≥n PERSISTENTE (reconecta 1 vez si falla).
    bool publish(const std::string& topic, const std::string& payload);

    // Opcional: timeout de socket (ms) para futuras conexiones.
    void set_timeout_ms(int ms) { timeout_ms_ = ms; }

    ~ProfilerClient();

private:
    ProfilerClient() = default;
    ProfilerClient(const ProfilerClient&) = delete;
    ProfilerClient& operator=(const ProfilerClient&) = delete;

    bool ensure_connected();   // crea y conecta si hace falta
    void close_socket();       // cierra y deja listo para reconectar
    bool set_timeouts();       // aplica SO_RCVTIMEO/SO_SNDTIMEO si se configur√≥

    std::string ip_;
    uint16_t    port_ = 0;
    std::string appId_;

#ifdef _WIN32
    static constexpr socket_t INVALID_SOCK = INVALID_SOCKET;
#else
    static constexpr socket_t INVALID_SOCK = (socket_t)-1;
#endif
    socket_t    sock_ = INVALID_SOCK;
    int         timeout_ms_ = 0;
    std::mutex  m_;
};


--------------------------------------------------

MetricsAggregator.h:
--------------------
#pragma once
#include <string>
#include <unordered_map>
#include <deque>
#include <mutex>
#include <atomic>
#include <cstdint>
#include <vector>

class MetricsAggregator {
public:
    struct BlockInfo {
        std::string ptr;     // clave (texto, ej. "0x7fff...")
        uint64_t    size = 0;
        std::string file;
        int         line = 0;
        std::string type;
        bool        is_array = false;
        uint64_t    ts_ns = 0; // timestamp del ALLOC (ns)
    };

    struct FileStats {
        uint64_t alloc_count = 0;  // total ALLOC (hist√≥rico)
        uint64_t alloc_bytes = 0;  // suma de bytes asignados (hist√≥rico)
        uint64_t live_count  = 0;  // actualmente vivos
        uint64_t live_bytes  = 0;  // bytes vivos actuales
    };

    struct TimelinePoint {
        uint64_t t_ns = 0;
        uint64_t current_bytes = 0;
        uint64_t leak_bytes = 0;
    };

    struct LeaksKPIs {
        uint64_t total_leak_bytes = 0;
        double   leak_rate = 0.0; // total_leaks / total_allocs
        struct { std::string file; std::string ptr; uint64_t size = 0; } largest;
        struct { std::string file; uint64_t count = 0; uint64_t bytes = 0; } top_file_by_leaks;
    };

    explicit MetricsAggregator(size_t timeline_capacity = 4096);

    // Procesa un evento JSON {"kind":"ALLOC"/"FREE", ...}
    void processEvent(const std::string& json);

    // Lecturas thread-safe para endpoints
    void getMetrics(uint64_t& current_bytes,
                    uint64_t& peak_bytes,
                    uint64_t& active_allocs,
                    uint64_t& total_allocs,
                    uint64_t& leak_bytes) const;

    std::vector<TimelinePoint> getTimeline() const;
    std::vector<BlockInfo> getBlocks() const;
    std::unordered_map<std::string, FileStats> getFileStats() const;
    LeaksKPIs getLeaksKPIs() const;

    // Configuraci√≥n
    void setLeakThresholdMs(uint64_t ms);
    uint64_t getLeakThresholdMs() const;

private:
    // ====== estado base tipo "contador" ======
    std::atomic<uint64_t> current_bytes_{0};
    std::atomic<uint64_t> peak_bytes_{0};
    std::atomic<uint64_t> active_allocs_{0};
    std::atomic<uint64_t> total_allocs_{0};
    std::atomic<uint64_t> leak_threshold_ms_{30000}; // 30 s

    // ====== estado protegido por mutex ======
    mutable std::mutex mtx_;
    std::unordered_map<std::string, BlockInfo> live_;        // ptr -> info
    std::unordered_map<std::string, FileStats> per_file_;    // file -> stats
    // timeline circular
    const size_t timeline_cap_;
    std::deque<TimelinePoint> timeline_;

    // ====== helpers ======
    static uint64_t now_ns();
    static uint64_t now_ms();

    // JSON helpers (simples, sin dependencias)
    static bool extractString(const std::string& json, const std::string& field, std::string& out);
    static bool extractUint64 (const std::string& json, const std::string& field, uint64_t& out);
    static bool extractInt    (const std::string& json, const std::string& field, int& out);
    static bool extractBool   (const std::string& json, const std::string& field, bool& out);

    // L√≥gica
    void onAlloc(const std::string& ptr, uint64_t size, uint64_t ts_ns,
                 const std::string& file, int line,
                 const std::string& type, bool is_array);
    void onFree (const std::string& ptr, uint64_t hinted_size);

    uint64_t computeLeakBytes_locked(uint64_t now_ns) const; // requiere mtx_ tomado
    void pushTimelinePoint_locked(uint64_t t_ns, uint64_t cur_b, uint64_t leak_b);

    // C√°lculo de KPIs de leaks (requiere mtx_ tomado)
    void computeLeaksKPIs_locked(uint64_t now_ns, LeaksKPIs& out) const;
};


--------------------------------------------------

MetricsCalculator.h:
--------------------
#pragma once
#include <string>
#include <atomic>
#include <mutex>
#include <unordered_map>
#include <chrono>

struct MetricsSnapshot {
    double current_mb;      // Memoria actual en MB
    uint64_t active_allocs; // Asignaciones activas (bloques vivos)
    double leak_mb;         // Memory leaks (seg√∫n umbral) en MB
    double peak_mb;         // Pico hist√≥rico en MB
    uint64_t total_allocs;  // Total de ALLOC procesados
    uint64_t timestamp_ms;  // Marca de tiempo del snapshot (epoch ms)

    std::string toJSON() const;
};

class MetricsCalculator {
public:
    MetricsCalculator();

    // Procesamiento de eventos JSON ("ALLOC"/"FREE")
    void processEvent(const std::string& jsonEvent);

    // M√©tricas actuales (thread-safe)
    MetricsSnapshot getSnapshot() const;

    // Configuraci√≥n de umbral de "leak" (en ms)
    void setLeakThresholdMs(uint64_t ms);

    // Reinicia estado y contadores
    void reset();

private:
    struct AllocInfo {
        uint64_t size = 0;
        uint64_t timestamp_ns = 0; // ts del evento (ns)
        std::string file;
        int line = 0;
        std::string type;
        bool is_array = false;
    };

    // Estado
    mutable std::mutex mtx_;
    std::unordered_map<std::string, AllocInfo> live_allocs_; // ptr -> info

    std::atomic<uint64_t> current_bytes_{0};
    std::atomic<uint64_t> peak_bytes_{0};
    std::atomic<uint64_t> active_allocs_{0};
    std::atomic<uint64_t> total_allocs_{0};
    std::atomic<uint64_t> leak_threshold_ms_{30000}; // 30s por defecto

    // Helpers privados
    void processAlloc(const std::string& ptr, uint64_t size, uint64_t ts_ns,
                      const std::string& file, int line,
                      const std::string& type, bool is_array);

    void processFree(const std::string& ptr, uint64_t hinted_size);

    uint64_t calculateLeakBytes() const;
    static uint64_t nowMs();
};


--------------------------------------------------

NetUtils.h:
-----------
#pragma once
#include <string>

// Tipos y macros cross-platform
#ifdef _WIN32
  #include <winsock2.h>
  #include <ws2tcpip.h>
  using socket_t = SOCKET;
#define CLOSESOCK closesocket
#define IS_INVALID(s) ((s)==INVALID_SOCKET)
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
using socket_t = int;
#define CLOSESOCK ::close
#define IS_INVALID(s) ((s)<0)
#endif

namespace net {

    // RAII para Winsock (no hace nada en Linux)
    struct WSAInit {
#ifdef _WIN32
        WSAInit();
        ~WSAInit();
#else
        WSAInit() = default;
        ~WSAInit() = default;
#endif
    };

    // Env√≠a todo el buffer (bloqueante). Devuelve true si tuvo √©xito.
    bool sendAll(socket_t s, const void* data, size_t len);

    // Lee hasta '\n' (bloqueante). Devuelve true si tuvo √©xito.
    bool recvLine(socket_t s, std::string& out);

} // namespace net


--------------------------------------------------

Protocol.h:
-----------
#pragma once
#include <string>
#include <vector>
#include <deque>
#include <unordered_map>
#include <optional>

namespace protocol {

    // Percent-encode solo los caracteres conflictivos con el pipe-protocol.
    std::string encode(const std::string& in);
    std::string decode(const std::string& in);

    // Divide l√≠nea de protocolo en tokens (maneja %xx).
    std::vector<std::string> split(const std::string& line);

    // Estructura de petici√≥n gen√©rica: COMANDO + args.
    struct Request {
        std::string command;
        std::vector<std::string> args;
    };

    std::optional<Request> parseLine(const std::string& line);

    // Helpers de respuesta
    inline std::string ok(const std::string& msg = {}) {
        return msg.empty() ? "OK\n" : "OK|" + encode(msg) + "\n";
    }
    inline std::string error(const std::string& msg) {
        return "ERROR|" + encode(msg) + "\n";
    }

    // T√≥picos del profiler
    static const char* TOPIC_MEMORY_UPDATE = "MEMORY_UPDATE";
    static const char* TOPIC_ALLOCATION    = "ALLOCATION";
    static const char* TOPIC_DEALLOCATION  = "DEALLOCATION";
    static const char* TOPIC_LEAK_DETECTED = "LEAK_DETECTED";
    static const char* TOPIC_FILE_STATS    = "FILE_STATS";

} // namespace protocol


--------------------------------------------------

SocketServer.h:
---------------
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <unordered_map>
#include <unordered_set>
#include <deque>
#include <mutex>
#include <optional>
#include "Protocol.h"
#include "NetUtils.h"   // <‚Äî usar utilidades comunes

// Broker pub/sub con SUBSCRIBE/UNSUBSCRIBE/PUBLISH/RECEIVE
class SocketServer {
public:
    explicit SocketServer(std::string ip, uint16_t port);
    ~SocketServer();

    void start();
    void stop();

private:
    void acceptLoop();
    void clientLoop(socket_t clientSock, std::string clientAddr);
    std::string process(const protocol::Request& req, const std::string& peerId);

    // Pub/sub
    std::unordered_map<std::string, std::unordered_set<std::string>> subscribers_;
    std::unordered_map<std::string, std::unordered_map<std::string, std::deque<std::string>>> queues_;
    std::unordered_map<std::string, socket_t> liveSockets_;

    std::mutex mtx_;

    // Red
    net::WSAInit wsa_;
    std::string ip_;
    uint16_t port_;
    socket_t listenSock_{};
    std::atomic<bool> running_{false};
};


--------------------------------------------------

BrokerClient.cpp:
-----------------
#include "BrokerClient.h"
#include "Protocol.h"
#include "NetUtils.h"

#include <cstring>   // std::strlen
#include <iostream>  // opcional para logs

#ifdef _WIN32
// NetUtils.h ya incluye headers de WinSock
#else
// NetUtils.h ya incluye <sys/socket.h>, <arpa/inet.h>, <unistd.h>
#endif

// Sentinel portable
#ifdef _WIN32
static constexpr socket_t INVALID_SOCK = INVALID_SOCKET;
#else
static constexpr socket_t INVALID_SOCK = (socket_t)-1;
#endif

BrokerClient::BrokerClient()
    : sock_(INVALID_SOCK),
      host_("127.0.0.1"),
      port_(5000),
      appId_("APP"),
      connected_(false) {}

BrokerClient::~BrokerClient() {
    disconnect();
}

void BrokerClient::configure(const std::string& host, uint16_t port, const std::string& appId) {
    std::lock_guard<std::mutex> lk(mtx_);
    host_  = host;
    port_  = port;
    appId_ = appId;
}

bool BrokerClient::connect() {
    std::lock_guard<std::mutex> lk(mtx_);
    if (connected_) return true;

    // Crear socket
    socket_t s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (IS_INVALID(s)) {
        connected_ = false;
        return false;
    }

    // Preparar direcci√≥n
    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port   = htons(port_);
    if (::inet_pton(AF_INET, host_.c_str(), &addr.sin_addr) != 1) {
        CLOSESOCK(s);
        connected_ = false;
        return false;
    }

    // Conectar
    if (::connect(s, (sockaddr*)&addr, sizeof(addr)) < 0) {
        CLOSESOCK(s);
        connected_ = false;
        return false;
    }

    // √âxito
    sock_ = s;
    connected_ = true;
    return true;
}

bool BrokerClient::sendLineLocked_(const std::string& line) {
    // Asume mtx_ tomado
    if (!connected_) return false;
    return net::sendAll(sock_, line.c_str(), line.size());
}

bool BrokerClient::recvLineLocked_(std::string& out) {
    // Asume mtx_ tomado
    if (!connected_) return false;
    return net::recvLine(sock_, out);
}

bool BrokerClient::subscribe(const std::string& topic) {
    std::lock_guard<std::mutex> lk(mtx_);
    if (!connected_) return false;

    // SUBSCRIBE|topic|appId\n  (respetando percent-encoding)
    std::string line = std::string("SUBSCRIBE|")
        + protocol::encode(topic) + "|"
        + protocol::encode(appId_) + "\n";

    if (!sendLineLocked_(line)) {
        connected_ = false;
        CLOSESOCK(sock_);
        sock_ = INVALID_SOCK;
        return false;
    }

    std::string resp;
    if (!recvLineLocked_(resp)) {
        connected_ = false;
        CLOSESOCK(sock_);
        sock_ = INVALID_SOCK;
        return false;
    }

    // Aceptamos "OK\n" o "OK|mensaje\n"
    if (resp.rfind("OK", 0) == 0) {
        return true;
    }

    // Si no fue OK, cerramos por simplicidad (puedes optar por mantener vivo)
    connected_ = false;
    CLOSESOCK(sock_);
    sock_ = INVALID_SOCK;
    return false;
}

std::string BrokerClient::receiveEvent() {
    std::lock_guard<std::mutex> lk(mtx_);
    if (!connected_) return {};

    std::string line;
    if (!recvLineLocked_(line)) {
        // Conexi√≥n rota / cerrada
        connected_ = false;
        if (!IS_INVALID(sock_)) {
            CLOSESOCK(sock_);
            sock_ = INVALID_SOCK;
        }
        return {};
    }

    // Esperamos l√≠neas del tipo:
    //   OK|<payload_codificado>\n
    //   (o eventualmente "ERROR|..."). Solo retornamos payload si es OK.
    if (line.rfind("OK|", 0) == 0) {
        // Extraer todo lo que viene tras el primer '|'
        // Nota: la l√≠nea trae '\n' al final; el decode del Protocol maneja %xx,
        // y el split elimina el '\n' del √∫ltimo token si corresponde.
        // Aqu√≠ haremos un split ligero usando helpers existentes.
        // Como queremos el JSON crudo, usamos split() para obtener tokens seguros.
        auto tokens = protocol::split(line);
        // tokens[0] = "OK", tokens[1] = payload (posible JSON codificado)
        if (tokens.size() >= 2) {
            return protocol::decode(tokens[1]);
        } else {
            // Es un "OK" sin payload (no deber√≠a pasar para eventos push),
            // devolvemos vac√≠o para no romper al caller.
            return {};
        }
    } else {
        // No es OK: ignoramos y devolvemos vac√≠o.
        return {};
    }
}

void BrokerClient::disconnect() {
    std::lock_guard<std::mutex> lk(mtx_);
    if (connected_) {
        connected_ = false;
    }
    if (!IS_INVALID(sock_)) {
        CLOSESOCK(sock_);
        sock_ = INVALID_SOCK;
    }
}

bool BrokerClient::isConnected() const {
    return connected_.load();
}


--------------------------------------------------

MemoryTracker.cpp:
------------------
#include "MemoryTracker.h"
#include <iostream>
#include <cstring>

ProfilerClient::~ProfilerClient() { close_socket(); }

ProfilerClient& ProfilerClient::instance() {
    static ProfilerClient s;
    return s;
}

void ProfilerClient::configure(const std::string& ip, uint16_t port, const std::string& appId) {
    std::lock_guard<std::mutex> lk(m_);
    ip_ = ip; port_ = port; appId_ = appId;
    close_socket(); // forzar nueva conexi√≥n con la nueva config
}

bool ProfilerClient::publish(const std::string& topic, const std::string& payload) {
    std::lock_guard<std::mutex> lk(m_);
    if (!ensure_connected()) return false;

    std::string line = "PUBLISH|" + protocol::encode(topic)
                     + "|" + protocol::encode(payload);
    if (!appId_.empty()) line += "|" + protocol::encode(appId_);
    line += "\n";

    if (!net::sendAll(sock_, line.c_str(), line.size())) {
        // Reintento 1: reconectar y volver a enviar
        close_socket();
        if (!ensure_connected()) return false;
        if (!net::sendAll(sock_, line.c_str(), line.size())) {
            close_socket();
            return false;
        }
    }
    return true;
}

bool ProfilerClient::ensure_connected() {
    if (!IS_INVALID(sock_)) return true;
    if (ip_.empty() || port_ == 0) return false;

    sock_ = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (IS_INVALID(sock_)) { sock_ = INVALID_SOCK; return false; }

    sockaddr_in a{}; a.sin_family = AF_INET; a.sin_port = htons(port_);
    if (::inet_pton(AF_INET, ip_.c_str(), &a.sin_addr) != 1) {
        close_socket(); return false;
    }
    if (::connect(sock_, (sockaddr*)&a, sizeof(a)) < 0) {
        close_socket(); return false;
    }
    (void)set_timeouts();
    return true;
}

void ProfilerClient::close_socket() {
    if (!IS_INVALID(sock_)) { CLOSESOCK(sock_); }
#ifdef _WIN32
    sock_ = INVALID_SOCKET;
#else
    sock_ = (socket_t)-1;
#endif
}

bool ProfilerClient::set_timeouts() {
    if (timeout_ms_ <= 0 || IS_INVALID(sock_)) return true;
#ifdef _WIN32
    DWORD tv = static_cast<DWORD>(timeout_ms_);
    setsockopt(sock_, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof(tv));
    setsockopt(sock_, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv, sizeof(tv));
#else
    timeval tv{};
    tv.tv_sec  = timeout_ms_ / 1000;
    tv.tv_usec = (timeout_ms_ % 1000) * 1000;
    setsockopt(sock_, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    setsockopt(sock_, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
#endif
    return true;
}


--------------------------------------------------

MetricsAggregator.cpp:
----------------------
#include "MetricsAggregator.h"
#include <chrono>
#include <cctype>
#include <sstream>
#include <algorithm>

MetricsAggregator::MetricsAggregator(size_t timeline_capacity)
    : timeline_cap_(timeline_capacity ? timeline_capacity : 4096) {}

uint64_t MetricsAggregator::now_ns() {
    using namespace std::chrono;
    return duration_cast<nanoseconds>(steady_clock::now().time_since_epoch()).count();
}
uint64_t MetricsAggregator::now_ms() {
    using namespace std::chrono;
    return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
}

// ------- JSON helpers (similares a los de MetricsCalculator, auto-contenidos) -------
namespace {
inline void skipSpaces(const std::string& s, size_t& i) {
    while (i < s.size() && std::isspace(static_cast<unsigned char>(s[i]))) ++i;
}
bool parseJSONStringAt(const std::string& s, size_t& i, std::string& out) {
    skipSpaces(s, i);
    if (i >= s.size() || s[i] != '"') return false;
    ++i;
    std::string acc;
    while (i < s.size()) {
        char c = s[i++];
        if (c == '\\') {
            if (i >= s.size()) break;
            char e = s[i++];
            if (e == '"' || e == '\\' || e == '/') acc.push_back(e);
            else if (e == 'b') acc.push_back('\b');
            else if (e == 'f') acc.push_back('\f');
            else if (e == 'n') acc.push_back('\n');
            else if (e == 'r') acc.push_back('\r');
            else if (e == 't') acc.push_back('\t');
            else acc.push_back(e);
        } else if (c == '"') {
            out.swap(acc);
            return true;
        } else {
            acc.push_back(c);
        }
    }
    return false;
}
bool seekFieldValue(const std::string& json, const std::string& field, size_t& i) {
    const std::string quoted = "\"" + field + "\"";
    size_t pos = json.find(quoted, i);
    if (pos == std::string::npos) return false;
    pos += quoted.size();
    while (pos < json.size() && std::isspace(static_cast<unsigned char>(json[pos]))) ++pos;
    if (pos >= json.size() || json[pos] != ':') return false;
    ++pos;
    i = pos;
    return true;
}
} // anon

bool MetricsAggregator::extractString(const std::string& json, const std::string& field, std::string& out) {
    size_t i = 0;
    if (!seekFieldValue(json, field, i)) return false;
    return parseJSONStringAt(json, i, out);
}
bool MetricsAggregator::extractBool(const std::string& json, const std::string& field, bool& out) {
    size_t i = 0;
    if (!seekFieldValue(json, field, i)) return false;
    skipSpaces(json, i);
    if (json.compare(i, 4, "true") == 0) { out = true;  return true; }
    if (json.compare(i, 5, "false") == 0){ out = false; return true; }
    return false;
}
bool MetricsAggregator::extractUint64(const std::string& json, const std::string& field, uint64_t& out) {
    size_t i = 0;
    if (!seekFieldValue(json, field, i)) return false;
    skipSpaces(json, i);
    if (i < json.size() && json[i] == '"') {
        std::string tmp;
        if (!parseJSONStringAt(json, i, tmp)) return false;
        if (tmp.rfind("0x", 0) == 0 || tmp.rfind("0X", 0) == 0) {
            char* endp = nullptr;
            unsigned long long v = std::strtoull(tmp.c_str(), &endp, 16);
            out = static_cast<uint64_t>(v);
            return true;
        } else {
            char* endp = nullptr;
            unsigned long long v = std::strtoull(tmp.c_str(), &endp, 10);
            out = static_cast<uint64_t>(v);
            return true;
        }
    } else {
        uint64_t v = 0; bool any = false;
        while (i < json.size() && std::isdigit(static_cast<unsigned char>(json[i]))) {
            any = true;
            v = v * 10 + static_cast<uint64_t>(json[i] - '0');
            ++i;
        }
        if (!any) return false;
        out = v;
        return true;
    }
}
bool MetricsAggregator::extractInt(const std::string& json, const std::string& field, int& out) {
    uint64_t u = 0;
    if (!extractUint64(json, field, u)) return false;
    out = static_cast<int>(u);
    return true;
}

// ------- l√≥gica -------
void MetricsAggregator::onAlloc(const std::string& ptr, uint64_t size, uint64_t ts_ns,
                                const std::string& file, int line,
                                const std::string& type, bool is_array) {
    total_allocs_.fetch_add(1, std::memory_order_relaxed);
    active_allocs_.fetch_add(1, std::memory_order_relaxed);
    uint64_t cur = current_bytes_.fetch_add(size, std::memory_order_relaxed) + size;

    // peak
    uint64_t old_peak = peak_bytes_.load(std::memory_order_relaxed);
    while (cur > old_peak &&
           !peak_bytes_.compare_exchange_weak(old_peak, cur, std::memory_order_relaxed)) {}

    {
        std::lock_guard<std::mutex> lk(mtx_);
        // registrar bloque
        BlockInfo bi;
        bi.ptr = ptr; bi.size = size; bi.file = file; bi.line = line; bi.type = type; bi.is_array = is_array; bi.ts_ns = ts_ns;
        live_[ptr] = bi;

        // actualizar por archivo
        auto& fs = per_file_[file];
        fs.alloc_count += 1;
        fs.alloc_bytes += size;
        fs.live_count  += 1;
        fs.live_bytes  += size;

        // timeline (usar now_ns para eje t)
        uint64_t t = now_ns();
        uint64_t leak_b = computeLeakBytes_locked(t);
        pushTimelinePoint_locked(t, cur, leak_b);
    }
}

void MetricsAggregator::onFree(const std::string& ptr, uint64_t hinted_size) {
    uint64_t sub = 0;
    std::string file;
    {
        std::lock_guard<std::mutex> lk(mtx_);
        auto it = live_.find(ptr);
        if (it != live_.end()) {
            sub = it->second.size;
            file = it->second.file;
            // actualizar por archivo
            auto fit = per_file_.find(file);
            if (fit != per_file_.end()) {
                if (fit->second.live_count > 0)  fit->second.live_count -= 1;
                if (fit->second.live_bytes >= sub) fit->second.live_bytes -= sub;
                else fit->second.live_bytes = 0;
            }
            live_.erase(it);
        }

        if (sub > 0) {
            // timeline point despu√©s de restar
            uint64_t cur_after = current_bytes_.load(std::memory_order_relaxed) - sub; // a√∫n no aplicado
            uint64_t t = now_ns();
            uint64_t leak_b = computeLeakBytes_locked(t);
            // (no a√∫n: actualizamos current fuera del lock para no mezclar)
            // guardamos el punto al final tras ajustar current_bytes_
            // para ser exactos, lo a√±adimos despu√©s del fetch_sub m√°s abajo
            // aqu√≠ no empujamos
        }
    }

    if (sub > 0) {
        current_bytes_.fetch_sub(sub, std::memory_order_relaxed);
        active_allocs_.fetch_sub(1, std::memory_order_relaxed);

        // push timeline con valores ya aplicados
        std::lock_guard<std::mutex> lk(mtx_);
        uint64_t t = now_ns();
        uint64_t cur = current_bytes_.load(std::memory_order_relaxed);
        uint64_t leak_b = computeLeakBytes_locked(t);
        pushTimelinePoint_locked(t, cur, leak_b);
    } else {
        (void)hinted_size;
    }
}

uint64_t MetricsAggregator::computeLeakBytes_locked(uint64_t now_ns_val) const {
    const uint64_t threshold_ns = leak_threshold_ms_.load(std::memory_order_relaxed) * 1000000ULL;
    uint64_t leak = 0;
    for (const auto& kv : live_) {
        const auto& bi = kv.second;
        if (now_ns_val > bi.ts_ns && (now_ns_val - bi.ts_ns) > threshold_ns) {
            leak += bi.size;
        }
    }
    return leak;
}

void MetricsAggregator::pushTimelinePoint_locked(uint64_t t_ns, uint64_t cur_b, uint64_t leak_b) {
    timeline_.push_back(TimelinePoint{t_ns, cur_b, leak_b});
    if (timeline_.size() > timeline_cap_) timeline_.pop_front();
}

void MetricsAggregator::computeLeaksKPIs_locked(uint64_t now_ns_val, LeaksKPIs& out) const {
    const uint64_t threshold_ns = leak_threshold_ms_.load(std::memory_order_relaxed) * 1000000ULL;
    // Por archivo
    std::unordered_map<std::string, std::pair<uint64_t/*count*/, uint64_t/*bytes*/>> per_file_leaks;

    uint64_t count_leaks = 0;
    uint64_t total_leak_b = 0;

    // largest
    uint64_t max_b = 0;
    std::string max_ptr, max_file;

    for (const auto& kv : live_) {
        const auto& bi = kv.second;
        if (now_ns_val > bi.ts_ns && (now_ns_val - bi.ts_ns) > threshold_ns) {
            ++count_leaks;
            total_leak_b += bi.size;
            auto& pf = per_file_leaks[bi.file];
            pf.first  += 1;
            pf.second += bi.size;

            if (bi.size > max_b) {
                max_b = bi.size;
                max_ptr = bi.ptr;
                max_file= bi.file;
            }
        }
    }

    // top_file_by_leaks
    std::string top_file;
    uint64_t top_count = 0, top_bytes = 0;
    for (const auto& kv : per_file_leaks) {
        if (kv.second.first > top_count || (kv.second.first == top_count && kv.second.second > top_bytes)) {
            top_file  = kv.first;
            top_count = kv.second.first;
            top_bytes = kv.second.second;
        }
    }

    out.total_leak_bytes = total_leak_b;
    const uint64_t total_allocs = total_allocs_.load(std::memory_order_relaxed);
    out.leak_rate = (total_allocs > 0) ? (double)count_leaks / (double)total_allocs : 0.0;
    out.largest.file = max_file;
    out.largest.ptr  = max_ptr;
    out.largest.size = max_b;
    out.top_file_by_leaks.file  = top_file;
    out.top_file_by_leaks.count = top_count;
    out.top_file_by_leaks.bytes = top_bytes;
}

void MetricsAggregator::processEvent(const std::string& json) {
    std::string kind;
    if (!extractString(json, "kind", kind)) return;

    if (kind == "ALLOC") {
        std::string ptr, file, type;
        uint64_t size = 0, ts_ns = 0;
        int line = 0; bool is_arr = false;
        extractString(json, "ptr", ptr);
        extractUint64(json, "size", size);
        extractUint64(json, "ts_ns", ts_ns);
        extractString(json, "file", file);
        extractInt   (json, "line", line);
        extractString(json, "type", type);
        extractBool  (json, "is_array", is_arr);
        if (!ptr.empty() && size > 0) onAlloc(ptr, size, ts_ns, file, line, type, is_arr);
    } else if (kind == "FREE") {
        std::string ptr; uint64_t hinted = 0;
        extractString(json, "ptr", ptr);
        extractUint64(json, "size", hinted);
        if (!ptr.empty()) onFree(ptr, hinted);
    }
}

void MetricsAggregator::getMetrics(uint64_t& current_bytes,
                                   uint64_t& peak_bytes,
                                   uint64_t& active_allocs,
                                   uint64_t& total_allocs,
                                   uint64_t& leak_bytes) const {
    current_bytes = current_bytes_.load(std::memory_order_relaxed);
    peak_bytes    = peak_bytes_.load(std::memory_order_relaxed);
    active_allocs = active_allocs_.load(std::memory_order_relaxed);
    total_allocs  = total_allocs_.load(std::memory_order_relaxed);
    std::lock_guard<std::mutex> lk(mtx_);
    leak_bytes    = computeLeakBytes_locked(now_ns());
}

std::vector<MetricsAggregator::TimelinePoint> MetricsAggregator::getTimeline() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return std::vector<TimelinePoint>(timeline_.begin(), timeline_.end());
}

std::vector<MetricsAggregator::BlockInfo> MetricsAggregator::getBlocks() const {
    std::vector<BlockInfo> out;
    std::lock_guard<std::mutex> lk(mtx_);
    out.reserve(live_.size());
    for (const auto& kv : live_) out.push_back(kv.second);
    return out;
}

std::unordered_map<std::string, MetricsAggregator::FileStats> MetricsAggregator::getFileStats() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return per_file_;
}

MetricsAggregator::LeaksKPIs MetricsAggregator::getLeaksKPIs() const {
    LeaksKPIs k{};
    std::lock_guard<std::mutex> lk(mtx_);
    computeLeaksKPIs_locked(now_ns(), k);
    return k;
}

void MetricsAggregator::setLeakThresholdMs(uint64_t ms) {
    leak_threshold_ms_.store(ms, std::memory_order_relaxed);
}
uint64_t MetricsAggregator::getLeakThresholdMs() const {
    return leak_threshold_ms_.load(std::memory_order_relaxed);
}


--------------------------------------------------

MetricsCalculator.cpp:
----------------------
#include "MetricsCalculator.h"

#include <sstream>
#include <iomanip>
#include <cctype>
#include <algorithm>

// -------------------------------
// Helpers locales para JSON simple
// -------------------------------

namespace {

// avanza i para saltar espacios
inline void skipSpaces(const std::string& s, size_t& i) {
    while (i < s.size() && std::isspace(static_cast<unsigned char>(s[i]))) ++i;
}

// extrae literal string: "...."
bool parseJSONStringAt(const std::string& s, size_t& i, std::string& out) {
    skipSpaces(s, i);
    if (i >= s.size() || s[i] != '"') return false;
    ++i; // salta comillas inicial
    std::string acc;
    while (i < s.size()) {
        char c = s[i++];
        if (c == '\\') {
            if (i >= s.size()) break;
            char e = s[i++];
            // soporto escapes b√°sicos
            if (e == '"' || e == '\\' || e == '/') acc.push_back(e);
            else if (e == 'b') acc.push_back('\b');
            else if (e == 'f') acc.push_back('\f');
            else if (e == 'n') acc.push_back('\n');
            else if (e == 'r') acc.push_back('\r');
            else if (e == 't') acc.push_back('\t');
            else acc.push_back(e);
        } else if (c == '"') {
            out.swap(acc);
            return true;
        } else {
            acc.push_back(c);
        }
    }
    return false;
}

// busca `"field":` y deja i al inicio del valor
bool seekFieldValue(const std::string& json, const std::string& field, size_t& i) {
    const std::string quoted = "\"" + field + "\"";
    size_t pos = json.find(quoted, i);
    if (pos == std::string::npos) return false;
    pos += quoted.size();
    // saltar espacios y colon
    while (pos < json.size() && std::isspace(static_cast<unsigned char>(json[pos]))) ++pos;
    if (pos >= json.size() || json[pos] != ':') return false;
    ++pos;
    i = pos;
    return true;
}

bool extractString(const std::string& json, const std::string& field, std::string& out) {
    size_t i = 0;
    if (!seekFieldValue(json, field, i)) return false;
    return parseJSONStringAt(json, i, out);
}

bool extractBool(const std::string& json, const std::string& field, bool& out) {
    size_t i = 0;
    if (!seekFieldValue(json, field, i)) return false;
    skipSpaces(json, i);
    if (json.compare(i, 4, "true") == 0) { out = true;  return true; }
    if (json.compare(i, 5, "false") == 0){ out = false; return true; }
    return false;
}

bool extractUint64(const std::string& json, const std::string& field, uint64_t& out) {
    size_t i = 0;
    if (!seekFieldValue(json, field, i)) return false;
    skipSpaces(json, i);
    // n√∫mero (decimal) o "0x..." como string (algunos emisores env√≠an ptr como string)
    if (i < json.size() && json[i] == '"') {
        // intentar leer string y luego parsear (por si viene "1234")
        std::string tmp;
        if (!parseJSONStringAt(json, i, tmp)) return false;
        if (tmp.rfind("0x", 0) == 0 || tmp.rfind("0X", 0) == 0) {
            // valor hexadecimal ‚Äî convertir a uint64
            char* endp = nullptr;
            unsigned long long v = std::strtoull(tmp.c_str(), &endp, 16);
            out = static_cast<uint64_t>(v);
            return true;
        } else {
            // decimal en string
            char* endp = nullptr;
            unsigned long long v = std::strtoull(tmp.c_str(), &endp, 10);
            out = static_cast<uint64_t>(v);
            return true;
        }
    } else {
        // n√∫mero crudo
        uint64_t v = 0;
        bool any = false;
        while (i < json.size() && std::isdigit(static_cast<unsigned char>(json[i]))) {
            any = true;
            v = v * 10 + static_cast<uint64_t>(json[i] - '0');
            ++i;
        }
        if (!any) return false;
        out = v;
        return true;
    }
}

// Permite leer un entero "line" que viene como n√∫mero
bool extractInt(const std::string& json, const std::string& field, int& out) {
    uint64_t u = 0;
    if (!extractUint64(json, field, u)) return false;
    out = static_cast<int>(u);
    return true;
}

} // namespace


// -------------------------------
// M√©tricas -> JSON
// -------------------------------
std::string MetricsSnapshot::toJSON() const {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2);
    oss << "{"
        << "\"current_mb\":"   << current_mb   << ","
        << "\"active_allocs\":"<< active_allocs<< ","
        << "\"leak_mb\":"      << leak_mb      << ","
        << "\"peak_mb\":"      << peak_mb      << ","
        << "\"total_allocs\":" << total_allocs << ","
        << "\"timestamp_ms\":" << timestamp_ms
        << "}";
    return oss.str();
}

// -------------------------------
// MetricsCalculator
// -------------------------------
MetricsCalculator::MetricsCalculator() = default;

void MetricsCalculator::processAlloc(const std::string& ptr, uint64_t size, uint64_t ts_ns,
                                     const std::string& file, int line,
                                     const std::string& type, bool is_array)
{
    // Ajuste contadores at√≥micos
    current_bytes_.fetch_add(size, std::memory_order_relaxed);
    active_allocs_.fetch_add(1, std::memory_order_relaxed);
    total_allocs_.fetch_add(1, std::memory_order_relaxed);

    // Peak
    uint64_t cur = current_bytes_.load(std::memory_order_relaxed);
    uint64_t prev_peak = peak_bytes_.load(std::memory_order_relaxed);
    while (cur > prev_peak && !peak_bytes_.compare_exchange_weak(prev_peak, cur, std::memory_order_relaxed)) {
        // prev_peak actualizado por compare_exchange_weak
    }

    // Registrar bloque vivo
    {
        std::lock_guard<std::mutex> lk(mtx_);
        live_allocs_[ptr] = AllocInfo{ size, ts_ns, file, line, type, is_array };
    }
}

void MetricsCalculator::processFree(const std::string& ptr, uint64_t hinted_size) {
    uint64_t size_to_sub = 0;
    bool found = false;

    {
        std::lock_guard<std::mutex> lk(mtx_);
        auto it = live_allocs_.find(ptr);
        if (it != live_allocs_.end()) {
            size_to_sub = it->second.size;
            live_allocs_.erase(it);
            found = true;
        }
    }

    if (found) {
        // Si el emisor env√≠a el size en FREE y difiere, preferimos el registrado en ALLOC
        current_bytes_.fetch_sub(size_to_sub, std::memory_order_relaxed);
        active_allocs_.fetch_sub(1, std::memory_order_relaxed);
        // peak no se reduce
    } else {
        // FREE hu√©rfano: ignorar sin afectar contadores
        (void)hinted_size;
    }
}

void MetricsCalculator::processEvent(const std::string& jsonEvent) {
    // Campos m√≠nimos
    std::string kind;
    if (!extractString(jsonEvent, "kind", kind)) return;

    if (kind == "ALLOC") {
        std::string ptr; (void)ptr;
        uint64_t size = 0, ts_ns = 0;
        std::string file, type;
        int line = 0; bool is_arr = false;

        // ptr suele venir como string:
        extractString(jsonEvent, "ptr", ptr);
        extractUint64(jsonEvent, "size", size);
        extractUint64(jsonEvent, "ts_ns", ts_ns);
        extractString(jsonEvent, "file", file);
        extractInt(jsonEvent, "line", line);
        extractString(jsonEvent, "type", type);
        extractBool(jsonEvent, "is_array", is_arr);

        if (!ptr.empty() && size > 0) {
            processAlloc(ptr, size, ts_ns, file, line, type, is_arr);
        }
    }
    else if (kind == "FREE") {
        std::string ptr; (void)ptr;
        uint64_t size = 0;
        extractString(jsonEvent, "ptr", ptr);
        extractUint64(jsonEvent, "size", size); // puede venir, pero no es obligatorio
        if (!ptr.empty()) {
            processFree(ptr, size);
        }
    }
    // otros "kind" se ignoran de momento
}

uint64_t MetricsCalculator::nowMs() {
    using namespace std::chrono;
    return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
}

uint64_t MetricsCalculator::calculateLeakBytes() const {
    const uint64_t now_ms = nowMs();
    const uint64_t threshold_ns = leak_threshold_ms_.load(std::memory_order_relaxed) * 1000000ULL;

    uint64_t leak = 0;
    std::lock_guard<std::mutex> lk(mtx_);
    for (const auto& kv : live_allocs_) {
        const auto& info = kv.second;
        uint64_t age_ns = (now_ms * 1000000ULL);
        if (age_ns > info.timestamp_ns) {
            age_ns -= info.timestamp_ns;
            if (age_ns > threshold_ns) leak += info.size;
        }
    }
    return leak;
}

MetricsSnapshot MetricsCalculator::getSnapshot() const {
    MetricsSnapshot s;
    const double MB = 1024.0 * 1024.0;

    const uint64_t cur_b  = current_bytes_.load(std::memory_order_relaxed);
    const uint64_t peak_b = peak_bytes_.load(std::memory_order_relaxed);

    s.current_mb    = static_cast<double>(cur_b)  / MB;
    s.peak_mb       = static_cast<double>(peak_b) / MB;
    s.active_allocs = active_allocs_.load(std::memory_order_relaxed);
    s.total_allocs  = total_allocs_.load(std::memory_order_relaxed);
    s.timestamp_ms  = nowMs();

    const uint64_t leak_b = calculateLeakBytes();
    s.leak_mb = static_cast<double>(leak_b) / MB;

    return s;
}

void MetricsCalculator::setLeakThresholdMs(uint64_t ms) {
    leak_threshold_ms_.store(ms, std::memory_order_relaxed);
}

void MetricsCalculator::reset() {
    {
        std::lock_guard<std::mutex> lk(mtx_);
        live_allocs_.clear();
    }
    current_bytes_.store(0, std::memory_order_relaxed);
    peak_bytes_.store(0, std::memory_order_relaxed);
    active_allocs_.store(0, std::memory_order_relaxed);
    total_allocs_.store(0, std::memory_order_relaxed);
    // No tocamos leak_threshold_ms_
}


--------------------------------------------------

NetUtils.cpp:
-------------
#include "NetUtils.h"
#include <iostream>

#ifdef _WIN32
  #pragma comment(lib,"ws2_32.lib")
#endif

namespace net {

#ifdef _WIN32
    WSAInit::WSAInit() {
        WSADATA wsaData{};
        if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
            std::cerr << "WSAStartup failed\n";
        }
    }
    WSAInit::~WSAInit() {
        WSACleanup();
    }
#endif

    bool sendAll(socket_t s, const void* data, size_t len) {
        const char* p = static_cast<const char*>(data);
        size_t total = 0;
        while (total < len) {
#ifdef _WIN32
            int sent = ::send(s, p + total, static_cast<int>(len - total), 0);
#else
            ssize_t sent = ::send(s, p + total, len - total, 0);
#endif
            if (sent <= 0) return false;
            total += static_cast<size_t>(sent);
        }
        return true;
    }

    bool recvLine(socket_t s, std::string& out) {
        out.clear();
        char c;
        while (true) {
#ifdef _WIN32
            int n = ::recv(s, &c, 1, 0);
#else
            ssize_t n = ::recv(s, &c, 1, 0);
#endif
            if (n <= 0) return false;
            out.push_back(c);
            if (c == '\n') break;
            if (out.size() > 65536) return false; // l√≠mite simple
        }
        return true;
    }

} // namespace net


--------------------------------------------------

Protocol.cpp:
-------------
#include "Protocol.h"
#include <sstream>
#include <iomanip>
#include <cctype>

namespace protocol {

std::string encode(const std::string& in) {
    std::ostringstream out;
    out << std::uppercase << std::hex;
    for (unsigned char c : in) {
        if (c == '|' || c == '\n' || c == '%' || c == '\\') {
            out << '%' << std::setw(2) << std::setfill('0') << int(c);
        } else {
            out << c;
        }
    }
    return out.str();
}

static inline int hex2(int a, int b) {
    auto val = [](int x)->int {
        if (x >= '0' && x <= '9') return x - '0';
        if (x >= 'A' && x <= 'F') return x - 'A' + 10;
        if (x >= 'a' && x <= 'f') return x - 'a' + 10;
        return -1;
    };
    int hi = val(a), lo = val(b);
    if (hi < 0 || lo < 0) return -1;
    return (hi << 4) | lo;
}

std::string decode(const std::string& in) {
    std::string out; out.reserve(in.size());
    for (size_t i = 0; i < in.size(); ++i) {
        if (in[i] == '%' && i + 2 < in.size()) {
            int v = hex2(in[i+1], in[i+2]);
            if (v >= 0) { out.push_back(static_cast<char>(v)); i += 2; }
            else out.push_back(in[i]);
        } else {
            out.push_back(in[i]);
        }
    }
    return out;
}

std::vector<std::string> split(const std::string& line) {
    std::vector<std::string> out;
    size_t start = 0, pos;
    while ((pos = line.find('|', start)) != std::string::npos) {
        out.push_back(decode(line.substr(start, pos - start)));
        start = pos + 1;
    }
    // √∫ltimo token (hasta fin o \n)
    if (start < line.size()) {
        std::string tail = line.substr(start);
        // eliminar '\n' de cola si viniera en el √∫ltimo token
        if (!tail.empty() && tail.back() == '\n') tail.pop_back();
        out.push_back(decode(tail));
    }
    return out;
}

std::optional<Request> parseLine(const std::string& line) {
    if (line.empty()) return std::nullopt;
    auto tokens = split(line);
    if (tokens.empty()) return std::nullopt;
    Request r;
    r.command = tokens[0];
    tokens.erase(tokens.begin());
    r.args = std::move(tokens);
    return r;
}

} // namespace protocol


--------------------------------------------------

SocketServer.cpp:
-----------------
#include "SocketServer.h"
#include "NetUtils.h"
#include <iostream>
#include <cstring>
#include <chrono>

#ifdef _WIN32
  #pragma comment(lib,"ws2_32.lib")
#endif

SocketServer::SocketServer(std::string ip, uint16_t port)
: ip_(std::move(ip)), port_(port) {
#ifdef _WIN32
    listenSock_ = INVALID_SOCKET;
#else
    listenSock_ = -1;
#endif
}

SocketServer::~SocketServer() {
    stop();
}

void SocketServer::start() {
    if (running_.exchange(true)) return;

    listenSock_ = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (IS_INVALID(listenSock_)) {
        running_ = false;
        throw std::runtime_error("No se pudo crear el socket de escucha");
    }

    int yes = 1;
#ifdef _WIN32
    setsockopt(listenSock_, SOL_SOCKET, SO_REUSEADDR, (const char*)&yes, sizeof(yes));
#else
    setsockopt(listenSock_, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
#endif

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port_);
    if (::inet_pton(AF_INET, ip_.c_str(), &addr.sin_addr) != 1) {
        CLOSESOCK(listenSock_);
        running_ = false;
        throw std::runtime_error("IP inv√°lida: " + ip_);
    }
    if (::bind(listenSock_, (sockaddr*)&addr, sizeof(addr)) < 0) {
        CLOSESOCK(listenSock_);
        running_ = false;
        throw std::runtime_error("bind() fall√≥");
    }
    if (::listen(listenSock_, 16) < 0) {
        CLOSESOCK(listenSock_);
        running_ = false;
        throw std::runtime_error("listen() fall√≥");
    }

    std::thread(&SocketServer::acceptLoop, this).detach();
    std::cout << "Broker escuchando en " << ip_ << ":" << port_ << std::endl;
}

void SocketServer::stop() {
    if (!running_.exchange(false)) return;
    if (!IS_INVALID(listenSock_)) {
        CLOSESOCK(listenSock_);
#ifdef _WIN32
        listenSock_ = INVALID_SOCKET;
#else
        listenSock_ = -1;
#endif
    }
}

void SocketServer::acceptLoop() {
    while (running_) {
        sockaddr_in cli{};
#ifdef _WIN32
        int len = sizeof(cli);
#else
        socklen_t len = sizeof(cli);
#endif
        socket_t cs = ::accept(listenSock_, (sockaddr*)&cli, &len);
        if (IS_INVALID(cs)) {
            if (!running_) break;
            continue;
        }
        char buf[INET_ADDRSTRLEN]{};
        inet_ntop(AF_INET, &cli.sin_addr, buf, sizeof(buf));
        std::string peer = buf;

        // LOG: cliente aceptado
        std::cout << "[ACCEPT] " << peer << std::endl;

        std::thread(&SocketServer::clientLoop, this, cs, peer).detach();
    }
}

void SocketServer::clientLoop(socket_t clientSock, std::string clientAddr) {
    std::string line;
    std::string peerId = clientAddr; // se actualizar√° si llega un appId en SUBSCRIBE

    while (running_) {
        if (!net::recvLine(clientSock, line)) {
            // LOG: desconexi√≥n
            std::cout << "[DISCONNECT] " << clientAddr << std::endl;
            break;
        }

        // LOG: l√≠nea recibida (incluye '\n')
        std::cout << "[RX] " << clientAddr << " " << line;

        auto reqOpt = protocol::parseLine(line);
        if (!reqOpt) {
            auto msg = protocol::error("Petici√≥n inv√°lida");
            std::cout << "[PARSE-ERR] " << clientAddr << " -> " << msg; // log del error enviado
            net::sendAll(clientSock, msg.c_str(), msg.size());
            continue;
        }

        auto resp = process(*reqOpt, peerId);

        // LOG: respuesta enviada
        std::cout << "[TX] " << clientAddr << " " << resp;

        net::sendAll(clientSock, resp.c_str(), resp.size());

        // Mantener socket vivo asociado a appId para push
        if (reqOpt->command == "SUBSCRIBE" && reqOpt->args.size() >= 2) {
            std::lock_guard<std::mutex> lock(mtx_);
            peerId = reqOpt->args[1];
            liveSockets_[peerId] = clientSock;
        } else if (reqOpt->command == "UNSUBSCRIBE" && reqOpt->args.size() >= 2) {
            std::lock_guard<std::mutex> lock(mtx_);
            liveSockets_.erase(reqOpt->args[1]);
        }
    }

    // limpiar socket saliente en mapa de sockets vivos
    {
        std::lock_guard<std::mutex> lock(mtx_);
        for (auto it = liveSockets_.begin(); it != liveSockets_.end();) {
            if (it->second == clientSock) it = liveSockets_.erase(it);
            else ++it;
        }
    }
    CLOSESOCK(clientSock);
}

std::string SocketServer::process(const protocol::Request& req, const std::string& peerId) {
    try {
        if (req.command == "SUBSCRIBE") {
            // SUBSCRIBE|topic|appId
            if (req.args.size() < 2) return protocol::error("Faltan par√°metros para SUBSCRIBE");
            const auto& topic = req.args[0];
            const auto& appId = req.args[1];
            std::lock_guard<std::mutex> lock(mtx_);
            subscribers_[topic].insert(appId);
            queues_[topic];
            queues_[topic][appId];

            // LOG detallado
            std::cout << "[SUBSCRIBE] topic=" << topic << " appId=" << appId << std::endl;

            return protocol::ok("Suscripci√≥n exitosa");
        }

        if (req.command == "UNSUBSCRIBE") {
            // UNSUBSCRIBE|topic|appId
            if (req.args.size() < 2) return protocol::error("Faltan par√°metros para UNSUBSCRIBE");
            const auto& topic = req.args[0];
            const auto& appId = req.args[1];
            std::lock_guard<std::mutex> lock(mtx_);
            if (!subscribers_.count(topic) || !subscribers_[topic].count(appId)) {
                return protocol::error("No est√° suscrito al tema: " + topic);
            }
            subscribers_[topic].erase(appId);
            if (queues_.count(topic)) queues_[topic].erase(appId);
            liveSockets_.erase(appId);

            // LOG detallado
            std::cout << "[UNSUBSCRIBE] topic=" << topic << " appId=" << appId << std::endl;

            return protocol::ok("Desuscripci√≥n exitosa");
        }

        if (req.command == "PUBLISH") {
            // PUBLISH|topic|payload|appId
            if (req.args.size() < 3) return protocol::error("Faltan par√°metros para PUBLISH");
            const auto& topic   = req.args[0];
            const auto& payload = req.args[1];
            const auto& appId   = req.args[2];

            size_t pushed = 0;
            size_t queued_for = 0;

            std::lock_guard<std::mutex> lock(mtx_);
            if (!subscribers_.count(topic) || subscribers_[topic].empty()) {
                // LOG sin suscriptores
                std::cout << "[PUBLISH] topic=" << topic << " from=" << appId
                          << " queued_for=0 pushed=0 (sin suscriptores)" << std::endl;
                return protocol::error("No hay suscriptores para el tema: " + topic);
            }

            queued_for = subscribers_[topic].size();
            for (const auto& sub : subscribers_[topic]) {
                queues_[topic][sub].push_back(payload);
                if (auto itSock = liveSockets_.find(sub); itSock != liveSockets_.end()) {
                    std::string pushLine = "OK|" + protocol::encode(payload) + "\n";
                    net::sendAll(itSock->second, pushLine.c_str(), pushLine.size());
                    ++pushed;
                }
            }

            // LOG detallado
            std::cout << "[PUBLISH] topic=" << topic
                      << " from=" << appId
                      << " queued_for=" << queued_for
                      << " pushed=" << pushed << std::endl;

            return protocol::ok("Mensaje publicado a " + std::to_string(pushed) + " suscriptores");
        }

        if (req.command == "RECEIVE") {
            // RECEIVE|topic|appId
            if (req.args.size() < 2) return protocol::error("Faltan par√°metros para RECEIVE");
            const auto& topic = req.args[0];
            const auto& appId = req.args[1];
            std::lock_guard<std::mutex> lock(mtx_);
            if (!subscribers_.count(topic) || !subscribers_[topic].count(appId)) {
                return protocol::error("No est√° suscrito al tema: " + topic);
            }
            auto& q = queues_[topic][appId];
            if (q.empty()) return protocol::error("No hay mensajes en la cola");
            std::string msg = q.front(); q.pop_front();

            // LOG detallado
            std::cout << "[RECEIVE] topic=" << topic
                      << " appId=" << appId << " delivered_one" << std::endl;

            return protocol::ok(msg);
        }

        // Atajos de profiler (tratan la l√≠nea como evento y la publican al topic hom√≥nimo)
        if (req.command == protocol::TOPIC_MEMORY_UPDATE ||
            req.command == protocol::TOPIC_ALLOCATION    ||
            req.command == protocol::TOPIC_DEALLOCATION  ||
            req.command == protocol::TOPIC_LEAK_DETECTED ||
            req.command == protocol::TOPIC_FILE_STATS) {

            if (req.args.empty()) return protocol::error("Faltan par√°metros");
            std::string payload;
            payload.reserve(256);
            payload += req.command;
            for (auto& a : req.args) { payload += '|'; payload += a; }

            std::string appId = req.args.back();
            if (appId.size() < 8) appId = peerId;

            size_t pushed = 0;
            size_t subs = 0;

            std::lock_guard<std::mutex> lock(mtx_);
            const std::string topic = req.command;
            subs = subscribers_[topic].size(); // 0 si nadie se suscribi√≥ a√∫n
            for (const auto& sub : subscribers_[topic]) {
                queues_[topic][sub].push_back(payload);
                if (auto itSock = liveSockets_.find(sub); itSock != liveSockets_.end()) {
                    std::string pushLine = "OK|" + protocol::encode(payload) + "\n";
                    net::sendAll(itSock->second, pushLine.c_str(), pushLine.size());
                    ++pushed;
                }
            }

            // LOG de evento de profiler
            std::cout << "[EVENT] " << req.command
                      << " subs=" << subs
                      << " pushed=" << pushed << std::endl;

            return protocol::ok("Evento " + req.command + " publicado a " + std::to_string(pushed));
        }

        return protocol::error("Comando desconocido: " + req.command);
    } catch (const std::exception& ex) {
        return protocol::error(std::string("Error interno: ") + ex.what());
    }
}


--------------------------------------------------

gui_http_server.cpp:
--------------------
#include <string>
#include <thread>
#include <atomic>
#include <vector>
#include <fstream>
#include <sstream>
#include <iostream>
#include <chrono>
#include <cctype>
#include <filesystem>
#include <iomanip>

#include "NetUtils.h"
#include "BrokerClient.h"
#include "Protocol.h"          // <-- para protocol::TOPIC_MEMORY_UPDATE
#include "MetricsAggregator.h" // agregador de m√©tricas

#ifdef _WIN32
  #include <winsock2.h>
  #include <ws2tcpip.h>
#else
  #include <arpa/inet.h>
  #include <sys/socket.h>
  #include <unistd.h>
#endif

// ===== Utilidades HTTP =====
static std::string mime_for(const std::string& path) {
    auto dot = path.find_last_of('.');
    std::string ext = (dot == std::string::npos) ? "" : path.substr(dot + 1);
    for (auto& c : ext) c = (char)std::tolower((unsigned char)c);
    if (ext == "html" || ext == "htm") return "text/html; charset=utf-8";
    if (ext == "js")   return "application/javascript; charset=utf-8";
    if (ext == "css")  return "text/css; charset=utf-8";
    if (ext == "json") return "application/json; charset=utf-8";
    if (ext == "png")  return "image/png";
    if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
    if (ext == "svg")  return "image/svg+xml";
    if (ext == "ico")  return "image/x-icon";
    return "application/octet-stream";
}

static bool read_file(const std::filesystem::path& p, std::string& out) {
    std::ifstream ifs(p, std::ios::binary);
    if (!ifs) return false;
    std::ostringstream oss;
    oss << ifs.rdbuf();
    out = oss.str();
    return true;
}

static void http_send_response(socket_t s, int code, const char* status,
                               const char* content_type, const std::string& body) {
    std::ostringstream head;
    head << "HTTP/1.1 " << code << " " << status << "\r\n"
         << "Content-Type: " << content_type << "\r\n"
         << "Content-Length: " << body.size() << "\r\n"
         << "Cache-Control: no-store\r\n"
         << "Connection: close\r\n\r\n";
    const auto header = head.str();
    net::sendAll(s, header.data(), header.size());
    if (!body.empty()) net::sendAll(s, body.data(), body.size());
}

static bool http_read_request(socket_t s, std::string& method, std::string& path) {
    std::string req;
    char buf[2048];
    for (;;) {
        int n = ::recv(s, buf, sizeof(buf), 0);
        if (n <= 0) break;
        req.append(buf, buf + n);
        if (req.find("\r\n\r\n") != std::string::npos) break;
        if (req.size() > 16384) break;
    }
    auto pos = req.find("\r\n");
    if (pos == std::string::npos) return false;
    std::string line = req.substr(0, pos);

    std::istringstream iss(line);
    iss >> method >> path;
    if (method.empty() || path.empty()) return false;
    return true;
}

static std::string url_decode(const std::string& in) {
    std::string out; out.reserve(in.size());
    for (size_t i=0; i<in.size(); ++i) {
        if (in[i] == '%' && i + 2 < in.size()) {
            int v = 0;
            std::istringstream(in.substr(i+1,2)) >> std::hex >> v;
            out.push_back(static_cast<char>(v));
            i += 2;
        } else if (in[i] == '+') {
            out.push_back(' ');
        } else {
            out.push_back(in[i]);
        }
    }
    return out;
}

static std::filesystem::path safe_join(const std::filesystem::path& root, std::string path) {
    if (path.empty() || path == "/") path = "/index.html";
    if (auto q = path.find('?'); q != std::string::npos) path = path.substr(0, q);
    path = url_decode(path);
    for (auto& c : path) if (c == '\\') c = '/';
    if (path.find("..") != std::string::npos) return {};
    if (!path.empty() && path.front() == '/') path.erase(0, 1);
    return root / path;
}

// ===== Bomba de eventos broker ‚Üí agregador =====
struct PumpConfig {
    std::string host = "127.0.0.1";
    uint16_t    port = 5000;
    std::string app  = "GUI-HTTP";
    std::string topic= protocol::TOPIC_MEMORY_UPDATE; // <-- alineado con test_socket
};

static void broker_pump_thread(const PumpConfig cfg, MetricsAggregator* agg, std::atomic<bool>* stop_flag) {
    BrokerClient client;
    client.configure(cfg.host, cfg.port, cfg.app);

    while (!stop_flag->load()) {
        if (!client.isConnected()) {
            if (client.connect() && client.subscribe(cfg.topic)) {
                std::cerr << "[gui_http] Suscrito a " << cfg.topic << "\n";
            } else {
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
                continue;
            }
        }
        std::string ev = client.receiveEvent(); // bloqueante
        if (ev.empty()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            continue;
        }
        agg->processEvent(ev);
    }
}

// ===== Servidor HTTP principal =====
int main(int argc, char** argv) {
    net::WSAInit wsa;

    uint16_t http_port = 8080;
    std::filesystem::path static_dir = "../gui";
    PumpConfig pump;

    for (int i=1; i<argc; ++i) {
        std::string a = argv[i];
        auto getv = [&](const char* /*key*/)->std::string {
            auto p = a.find('=');
            return (p==std::string::npos) ? "" : a.substr(p+1);
        };
        if (a.rfind("--port=",0)==0) http_port = static_cast<uint16_t>(std::stoi(getv("--port=")));
        else if (a.rfind("--static-dir=",0)==0) static_dir = getv("--static-dir=");
        else if (a.rfind("--host=",0)==0) pump.host = getv("--host=");
        else if (a.rfind("--bport=",0)==0) pump.port = static_cast<uint16_t>(std::stoi(getv("--bport=")));
        else if (a.rfind("--app=",0)==0) pump.app = getv("--app=");
        else if (a.rfind("--topic=",0)==0) pump.topic = getv("--topic="); // opcional, por si quieres cambiarlo
    }

    try { static_dir = std::filesystem::weakly_canonical(static_dir); } catch (...) {}
    std::cerr << "[gui_http] Static dir: " << static_dir.string() << "\n";
    std::cerr << "[gui_http] Broker: " << pump.host << ":" << pump.port << " app=" << pump.app << " topic=" << pump.topic << "\n";
    std::cerr << "[gui_http] HTTP:   127.0.0.1:" << http_port << "\n";

    MetricsAggregator agg(4096);
    // agg.setLeakThresholdMs(30000);

    std::atomic<bool> stop{false};
    std::thread th_pump(broker_pump_thread, pump, &agg, &stop);

    socket_t srv = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (IS_INVALID(srv)) {
        std::cerr << "[gui_http] ERROR: no pude crear socket HTTP\n";
        stop.store(true);
        th_pump.join();
        return 1;
    }
    int yes = 1;
#ifdef _WIN32
    setsockopt(srv, SOL_SOCKET, SO_REUSEADDR, (const char*)&yes, sizeof(yes));
#else
    setsockopt(srv, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
#endif

    sockaddr_in addr{}; addr.sin_family = AF_INET; addr.sin_port = htons(http_port);
    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
    if (::bind(srv, (sockaddr*)&addr, sizeof(addr)) < 0) {
        std::cerr << "[gui_http] ERROR: bind puerto " << http_port << "\n";
        CLOSESOCK(srv);
        stop.store(true);
        th_pump.join();
        return 1;
    }
    if (::listen(srv, 16) < 0) {
        std::cerr << "[gui_http] ERROR: listen\n";
        CLOSESOCK(srv);
        stop.store(true);
        th_pump.join();
        return 1;
    }

    std::cerr << "[gui_http] Sirviendo HTTP en http://127.0.0.1:" << http_port << "/ (ENTER para salir)\n";
    std::thread th_quit([&]{
        (void)getchar();
        stop.store(true);
#ifdef _WIN32
        ::closesocket(srv);
#else
        ::shutdown(srv, SHUT_RDWR);
        ::close(srv);
#endif
    });

    while (!stop.load()) {
        sockaddr_in cli{}; socklen_t clen = sizeof(cli);
        socket_t c = ::accept(srv, (sockaddr*)&cli, &clen);
        if (IS_INVALID(c)) {
            if (stop.load()) break;
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
            continue;
        }

        std::string method, path;
        if (!http_read_request(c, method, path)) {
            http_send_response(c, 400, "Bad Request", "text/plain; charset=utf-8", "Bad Request");
            CLOSESOCK(c); continue;
        }
        if (method != "GET") {
            http_send_response(c, 405, "Method Not Allowed", "text/plain; charset=utf-8", "Only GET");
            CLOSESOCK(c); continue;
        }

        // ====== ENDPOINTS JSON ======
        if (path == "/metrics") {
            uint64_t cur=0, peak=0, active=0, total=0, leak=0;
            agg.getMetrics(cur, peak, active, total, leak);
            std::ostringstream oss;
            oss << "{"
                << "\"current_bytes\":" << cur << ","
                << "\"peak_bytes\":"    << peak << ","
                << "\"active_allocs\":" << active << ","
                << "\"total_allocs\":"  << total << ","
                << "\"leak_bytes\":"    << leak
                << "}";
            http_send_response(c, 200, "OK", "application/json; charset=utf-8", oss.str());
            CLOSESOCK(c); continue;
        }

        if (path == "/timeline") {
            auto t = agg.getTimeline();
            std::ostringstream oss;
            oss << "[";
            for (size_t i=0; i<t.size(); ++i) {
                if (i) oss << ",";
                oss << "{"
                    << "\"t_ns\":" << t[i].t_ns << ","
                    << "\"current_bytes\":" << t[i].current_bytes << ","
                    << "\"leak_bytes\":"    << t[i].leak_bytes
                    << "}";
            }
            oss << "]";
            http_send_response(c, 200, "OK", "application/json; charset=utf-8", oss.str());
            CLOSESOCK(c); continue;
        }

        if (path == "/blocks") {
            auto v = agg.getBlocks();
            auto q = [](const std::string& s){ std::ostringstream o; o << "\"";
                for (char ch: s){ if (ch=='"'||ch=='\\') o<<'\\'<<ch; else o<<ch; } o<<"\""; return o.str(); };

            std::ostringstream oss;
            oss << "[";
            for (size_t i=0; i<v.size(); ++i) {
                if (i) oss << ",";
                oss << "{"
                    << "\"ptr\":"      << q(v[i].ptr)  << ","
                    << "\"size\":"     << v[i].size    << ","
                    << "\"file\":"     << q(v[i].file) << ","  // <-- corregido
                    << "\"line\":"     << v[i].line    << ","
                    << "\"type\":"     << q(v[i].type) << ","
                    << "\"is_array\":" << (v[i].is_array ? "true" : "false") << ","
                    << "\"ts_ns\":"    << v[i].ts_ns
                    << "}";
            }
            oss << "]";
            http_send_response(c, 200, "OK", "application/json; charset=utf-8", oss.str());
            CLOSESOCK(c); continue;
        }

        if (path == "/file-stats") {
            auto m = agg.getFileStats();
            auto qk = [](const std::string& s){ std::ostringstream o; o << "\"";
                for (char ch: s){ if (ch=='"'||ch=='\\') o<<'\\'<<ch; else o<<ch; } o<<"\""; return o.str(); };

            std::ostringstream oss;
            oss << "{";
            bool first = true;
            for (const auto& kv : m) {
                if (!first) oss << ",";
                first = false;
                oss << qk(kv.first) << ":{"
                    << "\"alloc_count\":" << kv.second.alloc_count << ","
                    << "\"alloc_bytes\":" << kv.second.alloc_bytes << ","
                    << "\"live_count\":"  << kv.second.live_count  << ","
                    << "\"live_bytes\":"  << kv.second.live_bytes
                    << "}";
            }
            oss << "}";
            http_send_response(c, 200, "OK", "application/json; charset=utf-8", oss.str());
            CLOSESOCK(c); continue;
        }

        if (path == "/leaks") {
            auto k = agg.getLeaksKPIs();
            auto q = [](const std::string& s){ std::ostringstream o; o << "\"";
                for (char ch: s){ if (ch=='"'||ch=='\\') o<<'\\'<<ch; else o<<ch; } o<<"\""; return o.str(); };
            std::ostringstream oss;
            oss << "{"
                << "\"total_leak_bytes\":" << k.total_leak_bytes << ","
                << std::fixed << std::setprecision(6)
                << "\"leak_rate\":"        << k.leak_rate << ","
                << "\"largest\":{"
                    << "\"file\":" << q(k.largest.file) << ","
                    << "\"ptr\":"  << q(k.largest.ptr)  << ","
                    << "\"size\":" << k.largest.size
                << "},"
                << "\"top_file_by_leaks\":{"
                    << "\"file\":"  << q(k.top_file_by_leaks.file)  << ","
                    << "\"count\":" << k.top_file_by_leaks.count    << ","
                    << "\"bytes\":" << k.top_file_by_leaks.bytes
                << "}"
            << "}";
            http_send_response(c, 200, "OK", "application/json; charset=utf-8", oss.str());
            CLOSESOCK(c); continue;
        }

        // ===== est√°ticos =====
        std::filesystem::path full = safe_join(static_dir, path);
        std::string body;
        if (full.empty() || !read_file(full, body)) {
            http_send_response(c, 404, "Not Found", "text/plain; charset=utf-8", "404 Not Found");
            CLOSESOCK(c); continue;
        }
        const std::string ctype = mime_for(full.string());
        http_send_response(c, 200, "OK", ctype.c_str(), body);
        CLOSESOCK(c);
    }

    if (th_pump.joinable()) th_pump.join();
    if (th_quit.joinable()) th_quit.join();
    return 0;
}


--------------------------------------------------

main.cpp:
---------
#include "SocketServer.h"
#include <iostream>

int main(int argc, char** argv) {
    try {
        std::string ip = "127.0.0.1";
        uint16_t port = 5000;
        if (argc >= 2) ip = argv[1];
        if (argc >= 3) port = static_cast<uint16_t>(std::stoi(argv[2]));

        SocketServer server(ip, port);
        server.start();

        std::cout << "Presiona ENTER para salir..." << std::endl;
        std::string dummy;
        std::getline(std::cin, dummy);

        server.stop();
        return 0;
    } catch (const std::exception& ex) {
        std::cerr << "Fallo fatal: " << ex.what() << std::endl;
        return 1;
    }
}


--------------------------------------------------

test_metrics.cpp:
-----------------
#include <cassert>
#include <iostream>
#include <thread>    // para std::this_thread
#include <chrono>    // para std::chrono::milliseconds
#include "MetricsCalculator.h"


int main() {
    MetricsCalculator calc;
    calc.setLeakThresholdMs(1); // umbral muy bajo para facilitar pruebas de leak

    // Simular dos ALLOC y un FREE
    calc.processEvent(R"({
        "kind":"ALLOC","ptr":"0x123","size":1024,
        "file":"a.cpp","line":10,"type":"int","is_array":false,
        "ts_ns": 1000000, "thread": 1
    })");
    calc.processEvent(R"({
        "kind":"ALLOC","ptr":"0x456","size":2048,
        "file":"b.cpp","line":20,"type":"char[]","is_array":true,
        "ts_ns": 2000000, "thread": 2
    })");
    calc.processEvent(R"({
        "kind":"FREE","ptr":"0x123","size":1024,
        "file":"a.cpp","line":10,"type":"int","is_array":false,
        "ts_ns": 3000000, "thread": 1
    })");

    auto snap = calc.getSnapshot();
    std::cout << "Snapshot: " << snap.toJSON() << "\n";

    // Comprobaciones (tolerancia por representaci√≥n en MB)
    // Vivo: solo 0x456 (2048 bytes)
    assert(snap.active_allocs == 1);
    assert(snap.total_allocs  == 2);

    // current_mb ‚âà 2048 / (1024*1024) ‚âà 0.00195 MB
    const double expected_cur_mb = 2048.0 / (1024.0 * 1024.0);
    assert(std::abs(snap.current_mb - expected_cur_mb) < 1e-6);

    // peak al menos el total tras el segundo ALLOC: (1024 + 2048) bytes
    const double expected_peak_mb = (1024.0 + 2048.0) / (1024.0 * 1024.0);
    assert(snap.peak_mb + 1e-6 >= expected_peak_mb);

    // Espera un poquito para que supere el umbral de leak y vuelva a tomar snapshot
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
    auto snap2 = calc.getSnapshot();
    // leak_mb deber√≠a contar 0x456 si ya pas√≥ el umbral
    assert(snap2.leak_mb >= expected_cur_mb - 1e-6);

    std::cout << "OK\n";
    return 0;
}


--------------------------------------------------

test_socket.cpp:
----------------
// tests/test_socket.cpp
// Test interactivo con men√∫: SUBSCRIBE / PUBLISH / LEGACY-BRIDGE

#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <chrono>
#include <atomic>
#include <cstring>
#include <cstdint>
#include <csignal>
#include <cstdio>       // std::snprintf
#include <mutex>
#include <filesystem>

#include "Protocol.h"
#include "MemoryTracker.h"  // ProfilerClient (SDK)
#include "NetUtils.h"
#include "LegacyBridge.h"   // instalar sink legacy -> broker

// ===== Consola UTF-8 en Windows (opcional) =====
#ifdef _WIN32
  #ifndef WIN32_LEAN_AND_MEAN
  #define WIN32_LEAN_AND_MEAN
  #endif
  #ifndef NOMINMAX
  #define NOMINMAX
  #endif
  #include <windows.h>
  static void setup_utf8_console() {
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
  }
#else
  static void setup_utf8_console() {}
#endif

#ifdef _WIN32
  constexpr socket_t INVALID_SOCK = INVALID_SOCKET;
#else
  constexpr socket_t INVALID_SOCK = (socket_t)-1;
#endif

// ===== Se√±al de salida segura =====
static std::atomic<bool> g_running{true};
static void on_sigint(int) { g_running = false; }

// ===== Helpers red =====
static socket_t connect_to(const std::string& ip, uint16_t port) {
  socket_t s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (IS_INVALID(s)) return INVALID_SOCK;
  sockaddr_in a{}; a.sin_family = AF_INET; a.sin_port = htons(port);
  if (::inet_pton(AF_INET, ip.c_str(), &a.sin_addr) != 1) { CLOSESOCK(s); return INVALID_SOCK; }
  if (::connect(s, (sockaddr*)&a, sizeof(a)) < 0)          { CLOSESOCK(s); return INVALID_SOCK; }
  return s;
}
static bool send_line(socket_t s, const std::string& line) {
  return net::sendAll(s, line.c_str(), line.size());
}

// ===== Auto-lanzar broker si no est√° (Windows) =====
#ifdef _WIN32
static bool ensure_broker_running(const std::string& host, uint16_t port, const char* argv0) {
  socket_t s = connect_to(host, port);
  if (!IS_INVALID(s)) { CLOSESOCK(s); return true; }
  std::filesystem::path exeDir = std::filesystem::path(argv0).parent_path();
  std::filesystem::path serverPath = exeDir / "memory_profiler_server.exe";
  if (!std::filesystem::exists(serverPath)) return false;
  std::string cmd = "\"" + serverPath.string() + "\" " + host + " " + std::to_string(port);
  STARTUPINFOA si{}; si.cb = sizeof(si); PROCESS_INFORMATION pi{};
  if (!CreateProcessA(NULL, cmd.data(), NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, exeDir.string().c_str(), &si, &pi))
    return false;
  CloseHandle(pi.hThread); CloseHandle(pi.hProcess);
  std::this_thread::sleep_for(std::chrono::milliseconds(300));
  s = connect_to(host, port);
  if (!IS_INVALID(s)) { CLOSESOCK(s); return true; }
  return false;
}
#endif

// ===== Estado de la app =====
struct AppState {
  std::string host = "127.0.0.1";
  uint16_t    port = 5000;
  std::string topic = protocol::TOPIC_MEMORY_UPDATE;
  std::string appId = "APP-1";

  // Suscriptor
  std::atomic<bool> sub_running{false};
  socket_t sub_sock = INVALID_SOCK;
  std::thread sub_thread;

  // Bridge
  std::atomic<bool> bridge_installed{false};

  std::mutex m; // proteger sub_sock
};
static AppState G;

// ===== Suscripci√≥n (start/stop) =====
static bool start_subscriber() {
  std::lock_guard<std::mutex> lk(G.m);
  if (G.sub_running) { std::cout << "Ya est√°s suscrito.\n"; return true; }
  G.sub_sock = connect_to(G.host, G.port);
  if (IS_INVALID(G.sub_sock)) { std::cout << "[sub] no se pudo conectar\n"; return false; }

  std::string line = std::string("SUBSCRIBE|") + protocol::encode(G.topic) + "|" + protocol::encode("GUI-1") + "\n";
  if (!send_line(G.sub_sock, line)) { std::cout << "[sub] fallo send\n"; CLOSESOCK(G.sub_sock); G.sub_sock = INVALID_SOCK; return false; }

  std::string resp;
  if (!net::recvLine(G.sub_sock, resp)) { std::cout << "[sub] sin respuesta\n"; CLOSESOCK(G.sub_sock); G.sub_sock = INVALID_SOCK; return false; }
  std::cout << "[sub] resp: " << resp << "\n";
  if (resp.rfind("OK", 0) != 0) { CLOSESOCK(G.sub_sock); G.sub_sock = INVALID_SOCK; return false; }

  G.sub_running = true;
  G.sub_thread = std::thread([]{
    std::string r;
    while (G.sub_running && net::recvLine(G.sub_sock, r)) {
      if (r.rfind("PUBLISH|", 0) == 0) std::cout << "[RX] " << r << "\n";
      r.clear();
    }
    std::lock_guard<std::mutex> lk(G.m);
    if (!IS_INVALID(G.sub_sock)) { CLOSESOCK(G.sub_sock); G.sub_sock = INVALID_SOCK; }
    G.sub_running = false;
  });
  return true;
}
static void stop_subscriber() {
  std::thread th;
  {
    std::lock_guard<std::mutex> lk(G.m);
    if (!G.sub_running) return;
    G.sub_running = false;
    if (!IS_INVALID(G.sub_sock)) { CLOSESOCK(G.sub_sock); G.sub_sock = INVALID_SOCK; }
    th = std::move(G.sub_thread);
  }
  if (th.joinable()) th.join();
}

// ===== Publicar ejemplos =====
static std::string make_sample_json(const char* kind, std::size_t bytes, int iter) {
  char buf[512];
  auto now = std::chrono::high_resolution_clock::now().time_since_epoch();
  auto ns  = std::chrono::duration_cast<std::chrono::nanoseconds>(now).count();

  // is_array: 1 si "ALLOC", 0 si no
  int is_array = (std::string(kind) == "ALLOC") ? 1 : 0;

  std::snprintf(buf, sizeof(buf),
    "{\"kind\":\"%s\",\"ptr\":\"0x%08X\",\"size\":%zu,"
    "\"file\":\"\",\"line\":0,\"type\":\"\",\"is_array\":%d,"
    "\"ts_ns\":%lld,\"thread\":%lld}",
    kind, 0xDEAD0000 + iter, bytes, is_array,
    (long long)ns, (long long)std::hash<std::thread::id>{}(std::this_thread::get_id()));
  return std::string(buf);
}
static void publish_sdk() {
  auto j1 = make_sample_json("ALLOC", 256, 1);
  auto j2 = make_sample_json("FREE",    0, 2);
  ProfilerClient::instance().configure(G.host, G.port, G.appId);
  bool a = ProfilerClient::instance().publish(G.topic, j1);
  bool b = ProfilerClient::instance().publish(G.topic, j2);
  std::cout << "[pub SDK] " << (a && b ? "OK" : "FALLO") << "\n";
}
static void publish_raw() {
  socket_t s = connect_to(G.host, G.port);
  if (IS_INVALID(s)) { std::cout << "[pub raw] no conecta\n"; return; }
  for (auto& j : { make_sample_json("ALLOC", 64, 3), make_sample_json("FREE", 0, 4) }) {
    std::string line = std::string("PUBLISH|") + protocol::encode(G.topic) + "|" + protocol::encode(j) + "|" + protocol::encode(G.appId) + "\n";
    if (!send_line(s, line)) { std::cout << "[pub raw] fallo send\n"; break; }
  }
  CLOSESOCK(s);
  std::cout << "[pub raw] OK\n";
}

// ===== Generar eventos reales (legacy) =====
static void generate_legacy_events(int rounds, int blocks, int elems) {
  for (int r = 0; r < rounds && g_running; ++r) {
    std::vector<int*> v; v.reserve(blocks);
    for (int i = 0; i < blocks; ++i) v.push_back(new int[elems]);
    for (int* p : v) delete[] p;
    std::this_thread::sleep_for(std::chrono::milliseconds(150));
  }
}
static void bridge_burst() {
  ProfilerClient::instance().configure(G.host, G.port, G.appId);
  if (!G.bridge_installed) {
    legacy_bridge::install_socket_sink(G.host, G.port, G.appId);
    G.bridge_installed = true;
  }
  int rounds=3, blocks=300, elems=256;
  std::cout << "rounds? [3] ";   std::string s; std::getline(std::cin, s); if (!s.empty()) rounds = std::stoi(s);
  std::cout << "blocks? [300] "; std::getline(std::cin, s); if (!s.empty()) blocks = std::stoi(s);
  std::cout << "elems?  [256] "; std::getline(std::cin, s); if (!s.empty()) elems  = std::stoi(s);
  std::cout << "[bridge] generando...\n";
  generate_legacy_events(rounds, blocks, elems);
  std::cout << "[bridge] listo.\n";
}

// ===== Men√∫ =====
static void print_menu() {
  std::cout <<
    "\n=== MemoryProfiler test (menu) ===\n"
    "Host: " << G.host << "  Port: " << G.port << "  AppId: " << G.appId << "\n"
    "1) Suscribirse y escuchar\n"
    "2) Parar suscripci√≥n\n"
    "3) Publicar ejemplo (SDK)\n"
    "4) Publicar ejemplo (raw)\n"
    "5) Generar eventos REALes (legacy new/delete)\n"
    "6) Cambiar host/puerto/appId\n"
    "7) Salir\n"
    "> ";
}

// ===== ACTIVAR LEGACY AL FINAL DE LOS INCLUDES =====
#define MEMPROF_ENABLE_NEW_MACRO
#include "memprof.hpp"   // ¬°nunca en headers y que no haya includes despu√©s!

int main(int /*argc*/, char** argv) {
  net::WSAInit wsa_guard;  // mantiene WinSock vivo (no-op en Linux)
  setup_utf8_console();
  std::signal(SIGINT, on_sigint);

#ifdef _WIN32
  (void)ensure_broker_running(G.host, G.port, argv[0]); // intenta arrancarlo si no responde
#endif

  std::string in;
  while (g_running) {
    print_menu();
    if (!std::getline(std::cin, in)) break;
    if (in.empty()) continue;

    switch (in[0]) {
      case '1': { if (start_subscriber()) std::cout << "[sub] escuchando...\n"; } break;
      case '2': { stop_subscriber(); std::cout << "[sub] parado.\n"; } break;
      case '3': publish_sdk(); break;
      case '4': publish_raw(); break;
      case '5': bridge_burst(); break;
      case '6': {
        std::string s;
        std::cout << "host [" << G.host << "]: ";   std::getline(std::cin, s); if (!s.empty()) G.host = s;
        std::cout << "port [" << G.port << "]: ";   std::getline(std::cin, s); if (!s.empty()) G.port = static_cast<uint16_t>(std::stoi(s));
        std::cout << "app  [" << G.appId << "]: ";  std::getline(std::cin, s); if (!s.empty()) G.appId = s;
        std::cout << "OK.\n";
      } break;
      case '7': g_running = false; break;
      default: std::cout << "Opci√≥n inv√°lida.\n"; break;
    }
  }

  stop_subscriber();
  std::cout << "Bye!\n";
  return 0;
}



